{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2021-04-06T10:24:41.000Z","updated":"2023-08-25T03:08:29.645Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-03-13T14:49:58.000Z","updated":"2023-11-29T02:53:14.496Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"济南超级计算技术研究院(实习生) 2022.02 - 2022.05 浪潮通信信息系统有限公司(实习生) 2022.11 - 2023.02 浪潮通信信息系统有限公司 2023.07 - 至今"}],"posts":[{"title":"CaNS移植指南","slug":"CaNS移植指南","date":"2022-04-19T06:46:14.000Z","updated":"2023-08-25T03:13:19.334Z","comments":true,"path":"2022/04/19/CaNS移植指南/","link":"","permalink":"http://example.com/2022/04/19/CaNS%E7%A7%BB%E6%A4%8D%E6%8C%87%E5%8D%97/","excerpt":"CaNS移植指南GitHub地址 CaNS介绍： CaNS（Canonical Navier-Stokes）是用于流体流动的大规模并行数值模拟的代码。它旨在求解不可压缩牛顿流体的任何流体流动，该流体可以受益于基于 FFT 的求解器，用于 3D 笛卡尔网格中的二阶有限差分泊松方程。 获取源码采用v1.1.4版本的代码","text":"CaNS移植指南GitHub地址 CaNS介绍： CaNS（Canonical Navier-Stokes）是用于流体流动的大规模并行数值模拟的代码。它旨在求解不可压缩牛顿流体的任何流体流动，该流体可以受益于基于 FFT 的求解器，用于 3D 笛卡尔网格中的二阶有限差分泊松方程。 获取源码采用v1.1.4版本的代码 123wget https://github.com/p-costa/CaNS/archive/refs/tags/v1.1.4.tar.gztar xzvf v1.1.4.tar.gzcd CaNS-1.1.4/ 编译安装进入src/main目录,修改Makefile中的LIBS 1LIBS = -L/path/to/fftw/lib -lfftw3 -lfftw3_threads 然后执行make,在当前目录下生成cans，或者可以执行make run，将生成的cans、data、dns.ini移动到../run， 1234makemake runcd ../runmpirun -np 4 cans dns.in spack 安装脚本package.py123456789101112131415161718192021222324252627282930313233343536373839# Copyright 2013-2021 Lawrence Livermore National Security, LLC and other# Spack Project Developers. See the top-level COPYRIGHT file for details.## SPDX-License-Identifier: (Apache-2.0 OR MIT)from spack import *class Cans(MakefilePackage): &quot;&quot;&quot;FIXME: Put a proper description of your package here.&quot;&quot;&quot; homepage = &quot;https://github.com/p-costa/CaNS&quot; url = &quot;https://github.com/p-costa/CaNS/archive/refs/tags/v1.1.4.tar.gz&quot; maintainers = [&#x27;lhxone&#x27;, &#x27;github_user2&#x27;] version(&#x27;1.1.4&#x27;, sha256=&#x27;8334c67810472edc18d5403a0bcb27fd57a620722c1e8c317518db4506867b81&#x27;) version(&#x27;1.1.3&#x27;, sha256=&#x27;01fa42e51ddcf6161fb63a124a0f2218c67f85ff4cc5236b995a5650d85e7615&#x27;) version(&#x27;1.1.2&#x27;, sha256=&#x27;31c8d6c1f619fb60b7919922c7a3a64dd614a1a2f89f38560184f75ed0526171&#x27;) version(&#x27;1.1.0&#x27;, sha256=&#x27;e3fd84902e18715c6476fe780e2395ca04db9e6b0c830b55a7aa9204b1fd0886&#x27;) # FIXME: Add dependencies if required. depends_on(&#x27;openmpi&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) depends_on(&#x27;fftw&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) def edit(self, spec, prefix): with working_dir(&#x27;src&#x27;): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(&#x27;LIBS =.*&#x27;, &#x27;LIBS = -L&#123;&#125; -lfftw3 -lfftw3_threads&#x27;.format(spec[&#x27;fftw&#x27;].prefix.lib)) def build(self, spec, prefix): with working_dir(&#x27;src&#x27;): make() def install(self, spec, prefix): mkdir(prefix.bin) with working_dir(&#x27;src&#x27;): install(&#x27;cans&#x27;, prefix.bin)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"CaNS","slug":"CaNS","permalink":"http://example.com/tags/CaNS/"},{"name":"流体力学","slug":"流体力学","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6/"},{"name":"工业仿真","slug":"工业仿真","permalink":"http://example.com/tags/%E5%B7%A5%E4%B8%9A%E4%BB%BF%E7%9C%9F/"}]},{"title":"suntans移植指南","slug":"suntans移植指南","date":"2022-04-19T06:29:43.000Z","updated":"2023-08-25T03:14:51.170Z","comments":true,"path":"2022/04/19/suntans移植指南/","link":"","permalink":"http://example.com/2022/04/19/suntans%E7%A7%BB%E6%A4%8D%E6%8C%87%E5%8D%97/","excerpt":"suntans-stanford官网 suntans-GitHub官网","text":"suntans-stanford官网 suntans-GitHub官网 suntans介绍： 斯坦福非结构化网格、非流体静力、平行沿海海洋模型。用于在河口和沿海以高分辨率模拟非静水流。需要网格生成器和 ParMETIS（如果并行运行）。 获取源码使用GitHub上的源码包： 12wget https://github.com/ofringer/suntans/archive/master.zipunzip suntans-master.zip 编译安装 如果已经安装X11则无需执行此步骤 进入main/，并修改Makefile 123456&gt;XLDFLAGS= -lX11 -lm&gt;XINC=/path/to/X11/lib&gt;XLIBDIR = /path/to/X11/lib&gt;INCLUDES = $(PARMETISINCLUDE) $(TRIANGLEINCLUDE) $(NETCDFINCLUDE) $(XINC) 执行make安装 12345cd suntans-master/examples/cylindermake testcd ../../mainmake sunplot./sunplot --datadir=../examples/cylinder/data spack安装脚本package.py12345678910111213141516171819202122232425262728293031323334353637383940414243# Copyright 2013-2021 Lawrence Livermore National Security, LLC and other# Spack Project Developers. See the top-level COPYRIGHT file for details.## SPDX-License-Identifier: (Apache-2.0 OR MIT)from spack import *class Suntans(MakefilePackage): &quot;&quot;&quot;The Stanford unstructured-grid, nonhydrostatic, parallel coastal ocean model. &quot;&quot;&quot; homepage = &quot;https://github.com/ofringer/suntans&quot; url = &quot;https://github.com/ofringer/suntans/archive/master.zip&quot; maintainers = [&#x27;ofringer&#x27;, &#x27;zyaj&#x27;, &#x27;mrayson&#x27;, &#x27;jadelson&#x27;, &#x27;lhxone&#x27;] version(&#x27;0.0.1&#x27;, &#x27;9b5d0dee5502a5650e37bf72f64b1124be86c084e7408aa517c214ddb25e36de&#x27;) depends_on(&#x27;libx11@1.6.3&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) depends_on(&#x27;openmpi&#x27;, type = (&#x27;build&#x27;)) def edit(self, spec, prefix): env[&#x27;MPIHOME&#x27;] = spec[&#x27;openmpi&#x27;].prefix with working_dir(&#x27;main&#x27;): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(&#x27;XINC=.*&#x27;, &#x27;XINC= -I&#123;0&#125;&#x27;.format(spec[&#x27;libx11&#x27;].prefix.include)) makefile.filter(&#x27;XLIBDIR = .*&#x27;, &#x27;XLIBDIR = &#123;0&#125;&#x27;.format(spec[&#x27;libx11&#x27;].prefix.lib)) makefile.filter(&#x27;INCLUDES = .*&#x27;, &#x27;INCLUDES = $(PARMETISINCLUDE) $(TRIANGLEINCLUDE) $(NETCDFINCLUDE) $(XINC)&#x27;) def build(self, spec, prefix): build_targets = [&#x27;CC = mpicc&#x27;] with working_dir(&#x27;examples/cylinder&#x27;): make(&#x27;test&#x27;) with working_dir(&#x27;main&#x27;): make(&#x27;sunplot&#x27;) def install(self, spec, prefix): mkdir(prefix.bin) mkdir(prefix.include) with working_dir(&#x27;main&#x27;): install(&#x27;sunplot&#x27;, prefix.bin) install(&#x27;*.h&#x27;, prefix.include)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"海洋科学","slug":"海洋科学","permalink":"http://example.com/tags/%E6%B5%B7%E6%B4%8B%E7%A7%91%E5%AD%A6/"},{"name":"suntans","slug":"suntans","permalink":"http://example.com/tags/suntans/"},{"name":"sunplot","slug":"sunplot","permalink":"http://example.com/tags/sunplot/"}]},{"title":"MITgcm移植指南","slug":"MITgcm移植指南","date":"2022-04-19T06:08:09.000Z","updated":"2023-08-25T03:15:32.231Z","comments":true,"path":"2022/04/19/MITgcm移植指南/","link":"","permalink":"http://example.com/2022/04/19/MITgcm%E7%A7%BB%E6%A4%8D%E6%8C%87%E5%8D%97/","excerpt":"MITgcm移植指南MITgcm官网软件介绍： MITgcm 灵活的非流体静力学公式是为研究大气、海洋和气候而设计的数值模型，","text":"MITgcm移植指南MITgcm官网软件介绍： MITgcm 灵活的非流体静力学公式是为研究大气、海洋和气候而设计的数值模型，使其能够有效地模拟各种尺度的流体现象；它的伴随能力使其能够应用于敏感性问题以及参数和状态估计问题。通过采用流体方程同构，可以使用单个动力学核来模拟大气和海洋的流动。该模型的开发是为了在各种计算平台上高效执行。 官方文档地址 获取源码源代码在GiThub:https://github.com/MITgcm/MITgcm/releases 我所使用的版本为2020mid 1234wget https://github.com/MITgcm/MITgcm/archive/refs/tags/checkpoint67s.tar.gzmv checkpoint67s.tar.gz MITGCM-2020-mid.tar.gztar xzvf MITGCM-2020-mid.tar.gzcd MITgcm-checkpoint67s 安装需要先进入build目录，然后使用genmake2生成Makefile 12cd verification/exp2/build../../../tools/genmake2 -mods ../code -optfile «/PATH/TO/OPTFILE» # ../../../tools/build_options/linux_amd64_gfortran 然后执行make等命令 12make dependmake 在build目录下生成mitgcmuv，完成 mpi安装mpi安装的官方文档 与上面的类似，只需要将genmake2命令替换为如下即可 123../../../tools/genmake2 -mods=../code -mpi -of=«/PATH/TO/OPTFILE» # ../../../tools/build_options/linux_amd64_gfortranmake dependmake openmp安装openmp安装的官方文档 与上面的类似，只需要将genmake2命令替换为如下即可 123../../../tools/genmake2 -mods=../code -omp -of=«/PATH/TO/OPTFILE» # ../../../tools/build_options/linux_amd64_gfortranmake dependmake spack安装脚本package.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Copyright 2013-2021 Lawrence Livermore National Security, LLC and other# Spack Project Developers. See the top-level COPYRIGHT file for details.## SPDX-License-Identifier: (Apache-2.0 OR MIT)from spack import *from os import systemclass Mitgcm(MakefilePackage): &quot;&quot;&quot;FIXME: Put a proper description of your package here.&quot;&quot;&quot; # FIXME: Add a proper url for your package&#x27;s homepage here. homepage = &quot;https://github.com/MITgcm/MITgcm&quot; url = &quot;https://github.com/MITgcm/MITgcm/archive/refs/tags/checkpoint67s.tar.gz&quot; maintainers = [&#x27;lhxone&#x27;, &#x27;MITgcm&#x27;] version(&#x27;67z&#x27;, sha256=&#x27;917c23045dab1939a5f0879192b2347c38d178e58f1ff6b2d91bb67bc8cc7e31&#x27;) version(&#x27;67s&#x27;, sha256=&#x27;0ad3139c5835db20c744fd50b46d307593a5c8fc3d6b6dd5e01a0eb22438977b&#x27;) version(&#x27;67m&#x27;, sha256=&#x27;d176bb4b8a0e49ebe0936d753aff1c9e2bb8800de63cd5b4001700df1292b72e&#x27;) version(&#x27;67g&#x27;, sha256=&#x27;3d1947584588ea75566f24185830481681467ad70f3498a0b8600d51d04f1d7b&#x27;) variant(&#x27;mpi&#x27;, default=False, description=&#x27;Use the specified C++ standard when building.&#x27;) variant(&#x27;openmp&#x27;, default=False, description=&#x27;Use the specified C++ standard when building.&#x27;) def build(self, spec, prefix): with working_dir(&#x27;verification/exp2/build&#x27;): if &#x27;+mpi&#x27; in spec: system(&#x27;cd &#123;0&#125;/verification/exp2/build &amp;&amp; ../../../tools/genmake2 -mods=../code -mpi -of=../../../tools/build_options/linux_amd64_gfortran&#x27;.format(self.stage.source_path)) elif &#x27;+omp&#x27; in spec: system(&#x27;cd &#123;0&#125;/verification/exp2/build &amp;&amp; ../../../tools/genmake2 -mods=../code -omp -of=../../../tools/build_options/linux_amd64_gfortran&#x27;.format(self.stage.source_path)) else system(&#x27;cd &#123;0&#125;/verification/exp2/build &amp;&amp; ../../../tools/genmake2 -mods ../code -optfile ../../../tools/build_options/linux_amd64_gfortran&#x27;.format(self.stage.source_path)) make(&#x27;depend&#x27;) make() def install(self, spec, prefix): mkdir(prefix.bin) with working_dir(&#x27;verification/exp2/build&#x27;): install(&#x27;mitgcmuv&#x27;, prefix.bin)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"MITgcm","slug":"MITgcm","permalink":"http://example.com/tags/MITgcm/"},{"name":"气候气象","slug":"气候气象","permalink":"http://example.com/tags/%E6%B0%94%E5%80%99%E6%B0%94%E8%B1%A1/"},{"name":"海洋科学","slug":"海洋科学","permalink":"http://example.com/tags/%E6%B5%B7%E6%B4%8B%E7%A7%91%E5%AD%A6/"}]},{"title":"CMAQ安装指北","slug":"CMAQ安装指北","date":"2022-04-15T01:35:37.000Z","updated":"2023-08-25T03:15:50.811Z","comments":true,"path":"2022/04/15/CMAQ安装指北/","link":"","permalink":"http://example.com/2022/04/15/CMAQ%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/","excerpt":"CMAQ移植安装CMAQ介绍： 美国环保署的一个活跃的开源开发项目，由一套用于进行空气质量模型模拟的程序组成。CMAQ 结合了当前在大气科学和空气质量建模、","text":"CMAQ移植安装CMAQ介绍： 美国环保署的一个活跃的开源开发项目，由一套用于进行空气质量模型模拟的程序组成。CMAQ 结合了当前在大气科学和空气质量建模、多处理器计算技术和开源框架方面的知识，以提供对臭氧、颗粒物、有毒物质和酸沉降的快速、技术上合理的估计。 前序准备此软件需要用到的依赖如下 软件名称 版本 下载地址 参考 CMAQ 5.3.1 https://codeload.github.com/USEPA/CMAQ/tar.gz/CMAQv5.3.1_19Dec2019 &#x2F; HDF5 1.10.1 https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.1/src/ HDF5安装手册 PnetCDF 1.9.0 https://parallel-netcdf.github.io/wiki/Download.html &#x2F; NetCDF-C 4.7.0 https://github.com/Unidata/netcdf-c/releases/tag/v4.7.0 netcdf-c安装手册 NetCDF-fortran 4.4.5 https://github.com/Unidata/netcdf-fortran/releases/tag/v4.4.5 netcdf-fortran安装手册 OPTIMIZED-ROUTINES V20.02 https://codeload.github.com/ARM-software/optimized-routines/tar.gz/v20.02 &#x2F; ioapi 3.2 https://codeload.github.com/cjcoats/ioapi-3.2/tar.gz/2020111 &#x2F; 测试算例 2016_12SE1 https://dataverse.unc.edu/dataset.xhtml?persistentId=doi:10.15139/S3/IQVABD &#x2F; ioapi安装先来看一下目录结构 1234567891011121314151617181920212223242526272829CMAQ/├── CMAQ-CMAQv5.3.1_19Dec2019│ ├── bldit_project.csh│ ├── CCTM│ ├── CMAQ_Project│ ├── config_cmaq.csh│ ├── DOCS│ ├── POST│ ├── PREP│ ├── README.md│ └── UTIL├── CMAQ_Project├── CMAQv5.3.1_19Dec2019.tar.gz├── ioapi-3.2│ ├── exclude│ ├── index.html│ ├── ioapi│ ├── LICENSE│ ├── Linux4_aarch64│ ├── m3tools│ ├── Makefile│ ├── Makefile.template│ ├── README│ ├── README.md│ ├── README.txt│ ├── tests│ ├── V32-CHANGES.txt│ └── VERSION.txt└── ioapi-3.2-2020111.tar.gz 先创建一个CMAQ工作目录，在此目录下解压CMAQ以及ioapi，并将解压好的ioapi重新命名为ioapi-3.2 12tar -xvf ioapi-3.2-2020111.tar.gzmv ioapi-3.2-2020111 ioapi-3.2 ioapi配置复制配置文件 12cd ioapi-3.2cp ioapi/Makeinclude.Linux2_ia64gfort ioapi/Makeinclude.Linux4_aarch64 修改ioapi/Makeinclude.Linux4_aarch64文件部分内容 Makeinclude.Linux4_aarch64123456CC = mpiccCXX = mpicxxFC = mpifort#FSFLAGS = -save 复制ioapi的Makefile文件 12cp ioapi/Makefile.nocpl ioapi/Makefileexport HOME=/path/to/CMAQ #很重要，CMAQ需要靠他寻找ioapi位置 m3tools配置复制m3tools的Makefile文件 1cp m3tools/Makefile.nocpl m3tools/Makefile 修改m3tools/Makefile内容 Makefile1LIBS = -L$&#123;OBJDIR&#125; -lioapi -L/path/to/NETCDF/lib -lnetcdff –lnetcdf -L/path/to /HDF5/lib -lhdf5_hl -lhdf5 -lz $(OMPLIBS) $(ARCHLIB) $(ARCHLIBS) CMAQ配置复制CMAQ的Makefile文件 1cp Makefile.template Makefile 修改如下内容 1234567891011BIN = Linux4_aarch64BASEDIR = $&#123;PWD&#125;INSTALL = $&#123;HOME&#125;LIBINST = $(INSTALL)/$(BIN)BININST = $(INSTALL)/$(BIN)CPLMODE = nocplIOAPIDEFS = &quot;-DIOAPI_NCF4&quot;NCFLIBS = -L/path/to/NETCDF/lib -lnetcdff -lnetcdf -L/path/to/HDF5/lib -lhdf5_hl -lhdf5 -lz 编译ioapi执行以下命令编译ioapi 1make BIN=Linux4_aarch64 修改STATE3.EXT文件,将行尾&amp;去掉 12345678910111213141516171819202122232425262728 !! non-character portion of current I/O API state !! Note that DOUBLE components are listed first, in order !! to ensure appropriate (64-bit, usually) alignment. COMMON / BSTATE3 / &amp; P_ALP3, P_BET3, P_GAM3, &amp; XCENT3, YCENT3, XORIG3, YORIG3, XCELL3, YCELL3, &amp; VGTYP3, VGTOP3, VGLVS3, &amp; FINIT3, COUNT3, CURDATE, CURTIME, LOGDEV, &amp; CDFID3, FTYPE3, SDATE3, STIME3, TSTEP3, MXREC3, &amp; NVARS3, NLAYS3, NROWS3, NCOLS3, NTHIK3, &amp; TINDX3, NINDX3, SINDX3, LINDX3, WCNDX3, WRNDX3, &amp; XINDX3, YINDX3, ZINDX3, DXNDX3, DYNDX3, VINDX3, &amp; GDTYP3, VOLAT3, RONLY3, &amp; BSIZE3, LDATE3, LTIME3, NDATE3, NTIME3, ILAST3, &amp; VTYPE3, &amp; ILCNT3, NLIST3, IFRST3, ILIST3, BEGRC3, ENDRC3, &amp; STDOUT, PN_MODE !! character portion of current I/O API state COMMON / CSTATE3 / &amp; EXECN3, SCNDSC, FLIST3, GDNAM3, VLIST3, UNITS3, VERSN3 SAVE / BSTATE3 / , / CSTATE3 /!................ end STATE3.EXT .................................... 编译CMAQ修改bldit_project.csh 12345cd CMAQ-CMAQv5.3.1_19Dec2019vim bldit_project.csh# 修改为对应的目录set CMAQ_HOME = /path/to/CMAQ/CMAQ_Project 运行以下命令来初始化所需文件 1./bldit_project.csh 进入工作目录并在case gcc处改配置文件 12cd ../CMAQ_Project/vim config_cmaq.csh config_cmaq.csh123456789101112131415setenv IOAPI_MOD_DIR /path/to/CMAQ/ioapi-3.2/Linux4_aarch64/setenv IOAPI_INCL_DIR /path/to/CMAQ/ioapi-3.2/ioapi/setenv IOAPI_LIB_DIR /path/to/CMAQ/ioapi-3.2/Linux4_aarch64/setenv NETCDF_LIB_DIR /path/to/NETCDF/lib/setenv NETCDF_INCL_DIR /path/to/NETCDF/include/setenv MPI_LIB_DIR /path/to/OPENMPI/setenv myCC mpiccsetenv myLINK_FLAG &quot;-fopenmp&quot;setenv mpi_lib &quot;-lmpi&quot;setenv netcdf_lib &quot;-lnetcdf -lnetcdff -lgomp&quot; #&gt; -lnetcdff -lnetcdf for netCDF v4.2.0 and later 执行以下命令链接各种依赖库 1./config_cmaq.csh gcc 9.3.0 依次执行以下命令，进入编译目录，并编译主程序 12cd CCTM/scripts/./bldit_cctm.csh gcc 9.3.0 编译完成后，会在“BLD_CCTM_v531_gcc9.3.0”目录下生成CMAQ的可执行程序CCTM_v531.exe spack安装代码package.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from spack import *from os import *class Cmaq(MakefilePackage): &quot;&quot;&quot;Code base for the U.S. EPA&#x27;s Community Multiscale Air Quality Model (CMAQ).&quot;&quot;&quot; homepage = &quot;https://www.epa.gov/CMAQ&quot; url = &quot;https://github.com/USEPA/CMAQ/archive/CMAQv5.3.1_19Dec2019.tar.gz&quot; version(&#x27;5.3.1&#x27;, sha256=&#x27;659156bba27f33010e0fdc157a8d33f3b5b779b95511e2ade870284b6bcb4bc8&#x27;, url=&#x27;https://github.com/USEPA/CMAQ/archive/CMAQv5.3.1_19Dec2019.tar.gz&#x27;) version(&#x27;5.3&#x27;, sha256=&#x27;e245c291c7e88d481b13f577d1af9aeb5aef4de8c59f7fa06fa41d19bb2ed18c&#x27;, url=&#x27;https://github.com/USEPA/CMAQ/archive/CMAQv5.3_27Aug2019.tar.gz&#x27;) depends_on(&#x27;openmpi&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) # depends_on(&#x27;mpich&#x27;, type = (&#x27;build&#x27;)) # depends_on(&#x27;netcdf-c&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) # depends_on(&#x27;netcdf-fortran&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) depends_on(&#x27;ioapi&#x27;, type = (&#x27;build&#x27;)) def edit(self, spec, prefix): csh = which(&#x27;csh&#x27;) bldit_project = FileFilter(&#x27;bldit_project.csh&#x27;) mkdirp(&#x27;CMAQ_Project&#x27;) bldit_project.filter(&#x27;set CMAQ_HOME .*&#x27;, &#x27;set CMAQ_HOME = &#x27; + self.stage.source_path + &#x27;/CMAQ_Project&#x27;) csh(&#x27;./bldit_project.csh&#x27;) config_cmaq = FileFilter(&#x27;config_cmaq.csh&#x27;) config_cmaq.filter(&#x27;setenv IOAPI_INCL_DIR .*&#x27;, &#x27;setenv IOAPI_INCL_DIR &#123;0&#125;&#x27;.format(spec[&#x27;ioapi&#x27;].prefix.include)) config_cmaq.filter(&#x27;setenv IOAPI_LIB_DIR .*&#x27;, &#x27;setenv IOAPI_LIB_DIR &#123;0&#125;&#x27;.format(spec[&#x27;ioapi&#x27;].prefix.Linux4_aarch64)) # config_cmaq.filter(&#x27;setenv NETCDF_LIB_DIR .*&#x27;, &#x27;setenv NETCDF_LIB_DIR &#123;0&#125;&#x27;.format(spec[&#x27;netcdf-c&#x27;].prefix.lib)) # config_cmaq.filter(&#x27;setenv NETCDF_INCL_DIR .*&#x27;, &#x27;setenv NETCDF_INCL_DIR &#123;0&#125;&#x27;.format(spec[&#x27;netcdf-c&#x27;].prefix.include)) # config_cmaq.filter(&#x27;setenv NETCDFF_LIB_DIR .*&#x27;, &#x27;setenv NETCDFF_LIB_DIR &#123;0&#125;&#x27;.format(spec[&#x27;netcdf-fortran&#x27;].prefix.lib)) # config_cmaq.filter(&#x27;setenv NETCDFF_INCL_DIR .*&#x27;, &#x27;setenv NETCDFF_INCL_DIR &#123;0&#125;&#x27;.format(spec[&#x27;netcdf-fortran&#x27;].prefix.include)) config_cmaq.filter(&#x27;setenv NETCDF_LIB_DIR .*&#x27;, &#x27;setenv NETCDF_LIB_DIR &#123;0&#125;&#x27;.format(&#x27;/es01/yeesuan/yeesuan003/cmaq/NETCDF/lib&#x27;)) config_cmaq.filter(&#x27;setenv NETCDF_INCL_DIR .*&#x27;, &#x27;setenv NETCDF_INCL_DIR &#123;0&#125;&#x27;.format(&#x27;/es01/yeesuan/yeesuan003/cmaq/NETCDF/include&#x27;)) config_cmaq.filter(&#x27;setenv NETCDFF_LIB_DIR .*&#x27;, &#x27;setenv NETCDFF_LIB_DIR &#123;0&#125;&#x27;.format(&#x27;/es01/yeesuan/yeesuan003/cmaq/NETCDF/lib&#x27;)) config_cmaq.filter(&#x27;setenv NETCDFF_INCL_DIR .*&#x27;, &#x27;setenv NETCDFF_INCL_DIR &#123;0&#125;&#x27;.format(&#x27;/es01/yeesuan/yeesuan003/cmaq/NETCDF/include&#x27;)) config_cmaq.filter(&#x27;setenv MPI_LIB_DIR .*&#x27;, &#x27;setenv MPI_LIB_DIR &#123;0&#125;&#x27;.format(spec[&#x27;openmpi&#x27;].prefix.lib)) config_cmaq.filter(&#x27;setenv myCC .*&#x27;, &#x27;setenv myCC mpicc&#x27;) config_cmaq.filter(&#x27;setenv myLINK_FLAG.*&#x27;, &quot;setenv myLINK_FLAG -fopenmp&quot;) config_cmaq.filter(&#x27;setenv mpi_lib .*&#x27;, &#x27;setenv mpi_lib &quot;-lmpi&quot;&#x27;) config_cmaq.filter(&#x27;setenv netcdff_lib .*&#x27;, &#x27;setenv netcdf_lib &quot;-lnetcdf -lnetcdff -lgomp&quot; #&gt; -lnetcdff -lnetcdf for netCDF v4.2.0 and later&#x27;) def build(self, spec, prefix): csh = which(&#x27;csh&#x27;) csh(&#x27;./config_cmaq.csh&#x27;, &#x27;gcc&#x27;, &#x27;9.3.0&#x27;) with working_dir(&#x27;CMAQ_Project/CCTM/scripts&#x27;): csh(&#x27;./bldit_cctm.csh&#x27;, &#x27;gcc&#x27;, &#x27;9.3.0&#x27;) with working_dir(&#x27;BLD_CCTM_v531_gcc9.3.0&#x27;): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(&#x27; include_path = -I .*&#x27;, &#x27; include_path = -I&#123;0&#125; \\\\&#x27;.format(spec[&#x27;ioapi&#x27;].prefix.lib)) makefile.filter(&#x27; -I \\$\\(LIB\\)/ioapi/include_files.*&#x27;, &#x27; -I&#123;0&#125; \\\\&#x27;.format(spec[&#x27;ioapi&#x27;].prefix.include)) makefile.filter(&#x27; -I \\$\\(LIB\\)/mpi .*&#x27;, &#x27; -I&#123;0&#125; -I.&#x27;.format(spec[&#x27;openmpi&#x27;].prefix.lib)) makefile.filter(&#x27;IOAPI =.*&#x27;, &#x27;IOAPI = -L&#123;0&#125; -lioapi&#x27;.format(spec[&#x27;ioapi&#x27;].prefix.lib)) makefile.filter(&#x27;NETCDF =.*&#x27;, &#x27;NETCDF = -L&#123;0&#125; -lnetcdff -lnetcdf&#x27;.format(&quot;/es01/yeesuan/yeesuan003/NETCDF/lib&quot;)) makefile.filter(&#x27;C_FLAGS = -O2 -DFLDMN .*&#x27;, &#x27; C_FLAGS = -O2 -DFLDMN -I&#123;0&#125; -I.&#x27;.format(&quot;/es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-skylake_avx512/gcc-8.5.0/intel-parallel-studio-cluster.2020.4-dsfubhta2i6ox2a666fhw2fvj6p2dupj/compilers_and_libraries_2020.4.304/linux/mpi/intel64/include&quot;)) makefile.filter(&#x27;LINK_FLAGS =.*&#x27;, &#x27;LINK_FLAGS = -fopenmp&#x27;) makefile.filter(&#x27;MPI_INC =.*&#x27;, &#x27;MPI_INC = /es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-skylake_avx512/gcc-8.5.0/mpich-3.4.2-433hbugctpbwp5trpk55d533gealrgvp/include&#x27;) make() def install(self, spec, prefix): mkdir(prefix.bin) with working_dir(&#x27;CMAQ_Project/CCTM/scripts/BLD_CCTM_v531_gcc9.3.0&#x27;): install(&#x27;CCTM_v531.exe&#x27;, prefix.bin)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"CMAQ","slug":"CMAQ","permalink":"http://example.com/tags/CMAQ/"},{"name":"ioapi","slug":"ioapi","permalink":"http://example.com/tags/ioapi/"},{"name":"环境科学","slug":"环境科学","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E7%A7%91%E5%AD%A6/"}]},{"title":"netcdf-c/netcdf-fortran安装指北","slug":"netcdf-c-netcdf-fortran安装指北","date":"2022-04-11T07:37:27.000Z","updated":"2023-08-25T03:16:08.802Z","comments":true,"path":"2022/04/11/netcdf-c-netcdf-fortran安装指北/","link":"","permalink":"http://example.com/2022/04/11/netcdf-c-netcdf-fortran%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/","excerpt":"以下安装需要依赖HDF5以及mpi环境：HDF5安装方法","text":"以下安装需要依赖HDF5以及mpi环境：HDF5安装方法 netcdf-c版本问题在安装NetCDF-C时,使用4.7.0版本的安装包报错,在GitHub上查到issue,更换最新版本解决 12checking whether byte range support is enabled... noconfigure: error: curl required for byte range support. Install curl or build without --enable-byterange. 获取源码源码地址为https://github.com/Unidata/netcdf-c/archive/refs/tags/v4.8.1.tar.gz,使用wget下载并解压源码 123wget https://github.com/Unidata/netcdf-c/archive/refs/tags/v4.8.1.tar.gztar -zxvf netcdf-c-4.8.1.tar.gzcd netcdf-c-4.8.1 配置安装执行以下命令进行配置、编译及安装 123./configure --prefix=/path/to/NETCDF LDFLAGS=&quot;-L$HDF5/lib&quot; CPPFLAGS=&quot;-I$HDF5/include&quot; CC=mpicc --disable-dapmake -jmake install 编辑环境变量1234vim ~/.bashrcexport PATH=&quot;/path/to/NETCDF/bin:$PATH&quot;export LD_LIBRARY_PATH=&quot;/path/to/NETCDF/lib:$LD_LIBRARY_PATH &quot;export NETCDF=&quot;/path/to/NETCDF&quot; netcdf-fortran获取源码源码地址为https://github.com/Unidata/netcdf-fortran/archive/refs/tags/v4.5.4.tar.gz,使用wget下载并解压 123wget https://github.com/Unidata/netcdf-fortran/archive/refs/tags/v4.5.4.tar.gztar -xzvf netcdf-fortran-4.5.4.tar.gzcd netcdf-fortran-4.5.4.tar.gz 配置安装执行以下命令进行配置 123./configure --prefix=/path/to/NETCDF CPPFLAGS=&quot;-I$HDF5/include -I$NETCDF/include&quot; LDFLAGS=&quot;-L$HDF5/lib -L$NETCDF/lib&quot; CC=mpicc FC=mpif90 F77=mpif90make -jmake install","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"}]},{"title":"HDF5安装指北","slug":"HDF5安装指北","date":"2022-04-11T07:37:02.000Z","updated":"2023-08-25T03:17:01.085Z","comments":true,"path":"2022/04/11/HDF5安装指北/","link":"","permalink":"http://example.com/2022/04/11/HDF5%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/","excerpt":"获取源码源码地址,使用wget下载并解压源码","text":"获取源码源码地址,使用wget下载并解压源码 123wget https://s3.amazonaws.com/hdf-wordpress-1/wp-content/uploads/manual/HDF5/HDF5_1_10_5/source/hdf5-1.10.5.tar.gztar -xvf hdf5-1.10.5.tar.gzcd hdf5-1.10.5 配置安装执行以下命令进行配置、编译及安装 123./configure --prefix=/path/to/install/HDF5 --enable-fortran --enable-parallel CC=mpicc FC=mpif90 CXX=mpicxxmake -jmake install","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"}]},{"title":"parmetis安装指北","slug":"parmetis安装指北","date":"2022-04-11T07:36:38.000Z","updated":"2023-08-25T03:17:13.424Z","comments":true,"path":"2022/04/11/parmetis安装指北/","link":"","permalink":"http://example.com/2022/04/11/parmetis%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/","excerpt":"PARMETIS&#x2F;parmetis下载地址：PARMETIS","text":"PARMETIS&#x2F;parmetis下载地址：PARMETIS 需要准备的依赖： cmake 获取源码123wget http://glaros.dtc.umn.edu/gkhome/fetch/sw/parmetis/parmetis-4.0.3.tar.gztar xzvf parmetis-4.0.3.tar.gzcd parmetis-4.0.3 进行一些修改修改metis/include/metis.h的第33行 1#define IDXTYPEWIDTH 64 进入metis目录，编译安装metis123cd metismake config shared=1 prefix=/es01/yeesuan/yeesuan003/software/METISmake install 进入上层目录，进行编译安装123cd ../make config shared=1 prefix=/es01/yeesuan/yeesuan003/software/METISmake install","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"parmetis","slug":"parmetis","permalink":"http://example.com/tags/parmetis/"}]},{"title":"WAVEWATCH III 6.07.1 移植指南","slug":"WAVEWATCH-III-6-07-1-移植指南","date":"2022-04-11T07:31:28.000Z","updated":"2023-08-25T03:17:46.315Z","comments":true,"path":"2022/04/11/WAVEWATCH-III-6-07-1-移植指南/","link":"","permalink":"http://example.com/2022/04/11/WAVEWATCH-III-6-07-1-%E7%A7%BB%E6%A4%8D%E6%8C%87%E5%8D%97/","excerpt":"WAVEWATCH III介绍： WAVEWATCH III ® 是一个社区波浪建模框架，其中包括风波建模和动力学领域的最新科学进展。","text":"WAVEWATCH III介绍： WAVEWATCH III ® 是一个社区波浪建模框架，其中包括风波建模和动力学领域的最新科学进展。 所需要的软件 项目 版本 下载地址 WAVEWATCH III 6.07.1 https://github.com/NOAA-EMC/WW3/releases/tag/6.07.1 HDF5 1.10.1 http://hdfgroup.org/HDF5/ NetCDF 4.4.1.1 https://github.com/Unidata/netcdf-c/releases/tag/v4.4.1.1 NetCDF-FORTRAN 4.4.1 https://github.com/Unidata/netcdf-fortran/releases/tag/v4.4.1 PARMETIS 4.0.3 http://glaros.dtc.umn.edu/gkhome/metis/parmetis/download 测试算例 mww3_data_01 ftp://polar.ncep.noaa.gov/tempor/ww3ftp/ww3_from_ftp.v6.07.tar.gz 获取源码下载地址WW3 1234wget https://github.com/NOAA-EMC/WW3/archive/refs/tags/6.07.1.tar.gzmv 6.07.1.tar.gz WAVEWATCH-III.v6.07.1.tar.gztar xzvf WAVEWATCH-III.v6.07.1.tar.gzcd WW3-6.07.1/ 环境变量准备env.sh12345678910111213141516171819############# gnu + openmpi #################export PATH=/path/to/GNU/bin:$PATHexport LD_LIBRARY_PATH=/path/to/GNU/lib64:$LD_LIBRARY_PATHexport PATH=/path/to/OpenMPI/bin:$PATHexport LD_LIBRARY_PATH=/path/to/OpenMPI/lib:$LD_LIBRARY_PATH############# netcdf #################export NETCDF_DIR=/path/to/NETCDFexport NETCDF_LIBDIR=$NETCDF_DIR/libexport NETCDF_INCDIR=$NETCDF_DIR/includeexport PATH=$NETCDF_DIR/bin:$PATHexport LD_LIBRARY_PATH=$NETCDF_LIBDIR:$LD_LIBRARY_PATHexport WWATCH3_NETCDF=NC4export NETCDF_CONFIG=$NETCDF_DIR/bin/nc-config############# metis #################export METIS_PATH=/path/to/METISexport PATH=$METIS_PATH/bin:$PATHexport LD_LIBRARY_PATH=$METIS_PATH/lib:$LD_LIBRARY_PATH 载入环境变量 1source env.sh 或者可以使用spack load openmpi 安装配置执行以下命令安装 1./model/bin/w3_setup model/ 运行与验证获取测试样例并解压到测试用目录 12345mkdir /path/to/WW3_TESTcd /path/to/WW3_TESTwget ftp://polar.ncep.noaa.gov/tempor/ww3ftp/ww3_from_ftp.v6.07.tar.gztar -xvf ww3_from_ftp.v6.07.tar.gzcd cases 环境变量设置 12source /path/to/env.shexport ww3_dir=/path/to/WAVEWATCH/WW3-6.07.1/model 修改mww3_case_01文件 第61行 1#cd /scratch1/portfolios/NCEPDEV/ocean/noscrub/Henrique.Alves/WW3_CASES/cases 第65行 1#module load intel mpt grads 第72行 1compstr=&quot;Gnu&quot; 第138行 1proc=96 第143行 1#ww3_dir=&#x27;echo $case_dir | sed &#x27;s/\\/cases\\/*//g&#x27;&#x27; 第420行,修改之后出现卡在Running multi-grid model ...的情况 1mpirun --allow-run-as-root --mca btl ^openib -np $proc --hostfile /path/to/WW3_TEST/hostfile $path_e/ww3_multi 运行样例，运行时间会特别长… 1./mww3_case_01 需要查看“work_case_01&#x2F;log.mww3”日志中的“Elapsed time”数值，单位是“s”，数值越少性能越优。","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"海洋科学","slug":"海洋科学","permalink":"http://example.com/tags/%E6%B5%B7%E6%B4%8B%E7%A7%91%E5%AD%A6/"}]},{"title":"swan移植指南","slug":"swan移植指南","date":"2022-04-11T06:27:01.000Z","updated":"2023-08-25T03:15:00.534Z","comments":true,"path":"2022/04/11/swan移植指南/","link":"","permalink":"http://example.com/2022/04/11/swan%E7%A7%BB%E6%A4%8D%E6%8C%87%E5%8D%97/","excerpt":"原文地址swan","text":"原文地址swan 修改platform.pl修改第406行 1print OUTFILE &quot;F90_MPI = mpifort\\n&quot;; 修改第414行 1print OUTFILE &quot;NETCDFROOT =/path/to/NETCDF\\n&quot;; 将第788行修改为$compiler = &quot;gfortran&quot;，或在环境变量中导入FC=gfortran 1234567891011121314sub getcmpl &#123; my $compiler = $ENV&#123;&#x27;FC&#x27;&#125;; unless ( $compiler ) &#123; foreach (&#x27;ifort&#x27;,&#x27;gfortran&#x27;,&#x27;f90&#x27;,&#x27;ifc&#x27;,&#x27;efc&#x27;,&#x27;pgf90&#x27;,&#x27;xlf90&#x27;, &#x27;lf95&#x27;,&#x27;g95&#x27;) &#123; $compiler = &quot;gfortran&quot;; my $path = `which $compiler`; last if $path; &#125; &#125; return $compiler;&#125; 编译安装执行make config生成配置文件，然后执行make mpi编译程序 12make configmake mpi spack安装代码package.py12345678910111213141516171819202122232425262728293031323334from spack import *from os import *class Swan(MakefilePackage): &quot;&quot;&quot;FIXME: Put a proper description of your package here.&quot;&quot;&quot; # FIXME: Add a proper url for your package&#x27;s homepage here. homepage = &quot;https://blog.lhxone.com&quot; url = &quot;file:///es01/yeesuan/yeesuan003/source/swan4131.tar.gz&quot; # FIXME: Add a list of GitHub accounts to version(&#x27;4131&#x27;, sha256=&#x27;cd3ba1f0d79123f1b7d42a43169f07575b59b01e604c5e66fbc09769e227432e&#x27;) # FIXME: Add dependencies if required. # depends_on(&#x27;intel-parallel-studio&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) depends_on(&#x27;mpich&#x27;, type = &#x27;build&#x27;) depends_on(&#x27;netcdf-fortran&#x27;, type = (&#x27;build&#x27;, &#x27;run&#x27;)) depends_on(&#x27;libfabric&#x27;, type = (&#x27;run&#x27;)) def edit(self, spec, prefix): env[&#x27;FC&#x27;] = &#x27;gfortran&#x27; makefile = FileFilter(&#x27;platform.pl&#x27;) makefile.filter(&#x27;F90_MPI = .*&#x27;, &#x27;F90_MPI = mpifort\\\\n&quot;;&#x27;) makefile.filter(&#x27;NETCDFROOT =&#x27;, &#x27;NETCDFROOT = /es01/yeesuan/yeesuan003/NETCDF&#x27;) def build(self, spec, prefix): make(&#x27;config&#x27;) make(&#x27;mpi&#x27;) def install(self, spec, prefix): mkdir(prefix.bin) install(&#x27;*.exe&#x27;, prefix.bin)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"海洋科学","slug":"海洋科学","permalink":"http://example.com/tags/%E6%B5%B7%E6%B4%8B%E7%A7%91%E5%AD%A6/"},{"name":"swan","slug":"swan","permalink":"http://example.com/tags/swan/"}]},{"title":"spack-Makefile使用手册","slug":"spack-Makefile使用手册","date":"2022-04-01T01:55:44.000Z","updated":"2023-08-25T03:18:11.237Z","comments":true,"path":"2022/04/01/spack-Makefile使用手册/","link":"","permalink":"http://example.com/2022/04/01/spack-Makefile%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"原文档链接：https://spack.readthedocs.io/en/latest/spack.build_systems.html#module-spack.build_systems.makefile","text":"原文档链接：https://spack.readthedocs.io/en/latest/spack.build_systems.html#module-spack.build_systems.makefile spack.build_systems.makefile 模块介绍使用可编辑 Makefile 构建的包的专用类 这个类提供了三个可以被覆盖的方法： edit build install 通常来说edit方法需要被覆盖，而build，install方法并不需要覆盖（bushi） 方法 目的 build_targets 指定build阶段的make目标 install_targets 指定install阶段的make目标 build_directory() Makefile所在的位置（build阶段所在的目录） 常用方法edit(self, spec, prefix)主要作用为在执行build之前编辑Makefile，例如修改各类依赖库的位置 经常用到的操作： 需要引用源码中的某些文件，因此要获取安装过程中源码位置 1pwd = os.getcwd() 需要编辑Makefile的某一项，示例地址：stream 12345678# 使用FileFilter正则表达式替换def edit(self, spec, prefix): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(r&#x27;^\\s*CC\\s*=.*&#x27;, &#x27;CC = &#x27; + spack_cc) makefile.filter(r&#x27;^\\s*CXX\\s*=.*&#x27;, &#x27;CXX = &#x27; + spack_cxx) makefile.filter(r&#x27;^\\s*F77\\s*=.*&#x27;, &#x27;F77 = &#x27; + spack_f77) makefile.filter(r&#x27;^\\s*FC\\s*=.*&#x27;, &#x27;FC = &#x27; + spack_fc) 或编辑类似make.inc的文件，示例地址：elk 123456789101112def edit(self, spec, prefix): config = &#123; &#x27;CC&#x27;: &#x27;cc&#x27;, &#x27;MAKE&#x27;: &#x27;make&#x27;, &#125; if &#x27;+blas&#x27; in spec: config[&#x27;BLAS_LIBS&#x27;] = spec[&#x27;blas&#x27;].libs.joined() with open(&#x27;make.inc&#x27;, &#x27;w&#x27;) as inc: for key in config: inc.write(&#x27;&#123;0&#125; = &#123;1&#125;\\n&#x27;.format(key, config[key])) 编辑环境变量，示例地址：cebench，esmf(较复杂) 12345678def edit(self, spec, prefix): env[&#x27;PREFIX&#x27;] = prefix env[&#x27;BLASLIB&#x27;] = spec[&#x27;blas&#x27;].libs.ld_flags# 或是 def setup_build_environment(self, env): # The location of the PRESTO source tree env.set(&#x27;PRESTO&#x27;, self.stage.source_path) build(self, spec,prefix)通过传递的build_targets参数，调用make 常用操作： 修改build目录(更喜欢用with working_dir(&#39;src&#39;):) 12build_directory = &#x27;src&#x27;make(&#x27;target&#x27;) setup_build_environment(self, env)设置build阶段的环境变量，示例如下： 123def setup_build_environment(self, env): env.append_path(&#x27;LD_LIBRARY_PATH&#x27;, self.stage.source_path + &#x27;/lib&#x27;) env.set(&#x27;PRESTO&#x27;, self.stage.source_path) 其余方法build(spec, prefix)[source]Calls make, passing build_targets as targets. propertybuild_directoryReturns the directory containing the main Makefile Returnsbuild directory build_system_class&#x3D; ‘MakefilePackage’This attribute is used in UI queries that need to know the build system base class build_targets&#x3D; []Targets for make during the build() phase build_time_test_callbacks&#x3D; [‘check’]Callback names for build-time test check()[source]Searches the Makefile for targets test and check and runs them if found. edit(spec, prefix)[source]Edits the Makefile before calling make. This phase cannot be defaulted. install(spec, prefix)[source]Calls make, passing install_targets as targets. install_targets&#x3D; [‘install’]Targets for make during the install() phase install_time_test_callbacks&#x3D; [‘installcheck’]Callback names for install-time test installcheck()[source]Searches the Makefile for an installcheck target and runs it if found. phases&#x3D; [‘edit’, ‘build’, ‘install’]Phases of a package that is built with an hand-written Makefile","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]},{"title":"presto系列软件的安装与使用","slug":"presto系列软件的安装与使用","date":"2022-03-31T03:23:10.000Z","updated":"2023-08-25T03:24:17.941Z","comments":true,"path":"2022/03/31/presto系列软件的安装与使用/","link":"","permalink":"http://example.com/2022/03/31/presto%E7%B3%BB%E5%88%97%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"presto系列软件的安装与使用 fftw","text":"presto系列软件的安装与使用 fftw 安装 1234567891011# float./configure --enable-float --prefix=/es01/yeesuan/yeesuan003/software/fftw CC=gcc F77=gfortran --enable-shared --enable-static --enable-sse --enable-sse2 --enable-avx --enable-avx2 --enable-fma --enable-mpi --enable-threads --enable-openmpmake -j &amp;&amp; make installmake clean# double./configure --prefix=/es01/yeesuan/yeesuan003/software/fftw3d CC=gcc F77=gfortran --enable-shared --enable-static --enable-sse2 --enable-avx --enable-avx2 --enable-fma --enable-mpi --enable-threads --enable-openmp 环境变量配置 12345678export PATH=/es01/yeesuan/yeesuan003/software/fftw/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export PATH=/es01/yeesuan/yeesuan003/software/fftw3d/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/fftw/libexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/fftw3d/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/fftw/includeexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/fftw3d/include 测试fftw 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;fftw3.h&gt;#define N 5int main()&#123; fftw_complex *in,*out; fftw_plan p; in = (fftw_complex*)fftw_malloc(sizeof (fftw_complex) * N); out= (fftw_complex*)fftw_malloc(sizeof (fftw_complex) * N); p= fftw_plan_dft_1d(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE); int n; for (n= 0; n &lt; N; n++) &#123; in[n][0]=1; in[n][1]= 2; &#125; fftw_execute(p); fftw_destroy_plan(p) ; for (n = 0; n &lt; N ;n++) &#123; printf(&quot;%3.2lf + %3.2lfi\\t&quot;, out[n][0],out[n][1]); &#125; printf(&quot;\\n&quot;); fftw_free(in); fftw_free(out); return 0;&#125; 编译运行 123[yeesuan003@spack test]$ gcc -o fftwtest fftwtest.c -I/es01/yeesuan/yeesuan003/software/fftw/include -I/es01/yeesuan/yeesuan003/software/fftw3d/include -L/es01/yeesuan/yeesuan003/software/fftw/lib -L/es01/yeesuan/yeesuan003/software/fftw3d/lib -lfftw3 -lfftw3f[yeesuan003@spack test]$ ./fftwtest5.00 + 10.00i 0.00 + 0.00i 0.00 + 0.00i 0.00 + 0.00i 0.00 + 0.00i pgplot修改drivers.list（去掉一些注释） 12345678910111213141516171819202122232425262728293031323334353637383940 17 ! GCDRIV 0 /GENICOM Genicom 4410 dot-matrix printer, landscape 18 ! Caution: use of GIDRIV may require a license from Unisys: 19 GIDRIV 1 /GIF GIF-format file, landscape 20 GIDRIV 2 /VGIF GIF-format file, portrait 21 ! GLDRIV 1 /HPGL Hewlett-Packard HP-GL plotters, landscape Std F77········· 36 ! MFDRIV 0 /FILE PGPLOT graphics metafile 37 ! NEDRIV 0 /NEXT Computers running NeXTstep operating system 38 NUDRIV 0 /NULL Null device (no output) Std F77 39 ! PGDRIV 0 /PGMF PGPLOT metafile (new format, experimental) Std F77 40 ! PNDRIV 1 /PNG Portable Network Graphics file C 41 ! PNDRIV 2 /TPNG Portable Network Graphics file - transparent background C 42 ! PPDRIV 1 /PPM Portable Pixel Map file, landscape 43 ! PPDRIV 2 /VPPM Portable PIxel Map file, portrait 44 PSDRIV 1 /PS PostScript printers, monochrome, landscape Std F77 45 PSDRIV 2 /VPS Postscript printers, monochrome, portrait Std F77 46 PSDRIV 3 /CPS PostScript printers, color, landscape Std F77 47 PSDRIV 4 /VCPS PostScript printers, color, portrait Std F77 48 ! PXDRIV 0 /PRINTRONI Printronix P300 or P600 dot-matrix printer 49 ! QMDRIV 1 /QMS QUIC devices (QMS and Talaris), landscape Std F77········· 67 ! WDDRIV 1 /WD X Window dump file, landscape 68 ! WDDRIV 2 /VWD X Window dump file, portrait 69 ! WSDRIV 0 /WS VAX workstations running VWS software VMS 70 ! X2DRIV 0 /XDISP PGDISP or FIGDISP server for X workstations C 71 XWDRIV 1 /XWINDOW Workstations running X Window System C 72 XWDRIV 2 /XSERVE Persistent window on X Window System C 73 ! ZEDRIV 0 /ZETA Zeta 8 Digital Plotter 74 ! 75 ! The following drivers can only be used in PGPLOT installations on MS-DOS 76 ! systems with appropriate hardware and software. Do not select these 77 ! on UNIX or VMS systems. 将driver.list拷贝到安装目录下 1cp drivers.list ~/software/pgplot/ 12345678910111213141516# manualexport PGPLOT_DIR=/es01/yeesuan/yeesuan003/software/pgplotexport PGPLOT_DEV=/Xserveexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/pgplot/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/pgplot/includeexport PGPLOT_FONT=/es01/yeesuan/yeesuan003/software/pgplot/grfont.datexport PGPLOT_LIB=&quot;-L/es01/jnist/software/common/linux-centos7-skylake_avx512/gcc-8.5.0/libx11-1.7.0-2ovdqwa5f77pnonzmft6ttzmblxxibbe/lib -lX11 -L/es01/yeesuan/yeesuan003/software/pgplot/lib -lpgplot&quot;# spackexport PGPLOT_DIR=/es01/yeesuan/yeesuan003/software/pgplotexport PGPLOT_DEV=/Xserveexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-skylake_avx512/gcc-8.5.0/pgplot-5.2.2-nwyu3d24mn4mrjgrg2khh34gwxsiegnc/lib/export C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-skylake_avx512/gcc-8.5.0/pgplot-5.2.2-nwyu3d24mn4mrjgrg2khh34gwxsiegnc/includeexport PGPLOT_FONT=/es01/yeesuan/yeesuan003/software/pgplot/grfont.datexport PGPLOT_LIB=&quot;-L/es01/jnist/software/common/linux-centos7-skylake_avx512/gcc-8.5.0/libx11-1.7.0-2ovdqwa5f77pnonzmft6ttzmblxxibbe/lib -lX11 -L/es01/yeesuan/yeesuan003/software/pgplot/lib -lpgplot&quot; 测试，执行./pgdemo1出现下图 tempo212./configure --prefix=/es01/yeesuan/yeesuan003/software/tempo2make -j &amp;&amp; make install 环境变量 123export TEMPO2=/es01/yeesuan/yeesuan003/software/tempo2export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/tempo2/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/tempo2/include libffi1./configure --prefix=/es01/yeesuan/yeesuan003/software/libffi 123export LIBFFI=/es01/yeesuan/yeesuan003/software/libffiexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/libffi/lib64export C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/libffi/include glib1234xz -d glib-2.48.1.tar.xztar xvf glib-2.48.1.tarcd glib-2.48.1./configure --prefix=/es01/yeesuan/yeesuan003/software/glib 12345cp /es01/yeesuan/yeesuan003/software/glib/lib/glib-2.0/include/glibconfig.h /es01/yeesuan/yeesuan003/software/glib/include/glib-2.0export GLIB=/es01/yeesuan/yeesuan003/software/glibexport PATH=/es01/yeesuan/yeesuan003/software/glib/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/glib/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/glib/include 测试 12345678//glibtest.c#include &lt;stdio.h&gt;#include &quot;glib.h&quot;int main()&#123; g_printf(&quot;hello world\\n&quot;); return 0;&#125; 12gcc -o glibtest glibtest.c -I/es01/yeesuan/yeesuan003/software/glib/include/glib-2.0 -L/es01/yeesuan/yeesuan003/software/glib/lib -lglib-2.0./glibtest curl1./configure --prefix=/es01/yeesuan/yeesuan003/software/curl 123export PATH=/es01/yeesuan/yeesuan003/software/curl/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/curl/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/curl/include cfitsio1./configure --prefix=/es01/yeesuan/yeesuan003/software/cfitsio 123export CFITSIO=/es01/yeesuan/yeesuan003/software/cfitsioexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/cfitsio/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/cfitsio/include 123456789101112131415161718192021// cfitsiotest.cpp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;fitsio.h&quot;int main(int argc, char *argv[])&#123; fitsfile *fptr; char card[FLEN_CARD]; int status = 0, nkeys, ii; /* MUST initialize status */ fits_open_file(&amp;fptr, argv[1], READONLY, &amp;status); fits_get_hdrspace(fptr, &amp;nkeys, NULL, &amp;status); for (ii = 1; ii &lt;= nkeys; ii++) &#123; fits_read_record(fptr, ii, card, &amp;status); /* read keyword */ printf(&quot;%s\\n&quot;, card); &#125; printf(&quot;END\\n\\n&quot;); /* terminate listing with END */ fits_close_file(fptr, &amp;status); if (status) /* print any error messages */ fits_report_error(stderr, status); return(status);&#125; 1234g++ -o cfitsiotest cfitsiotest.cpp -L/es01/yeesuan/yeesuan003/software/cfitsio/lib -L/es01/yeesuan/yeesuan003/software/curl/lib -I/es01/yeesuan/yeesuan003/software/cfitsio/include -lm -lcfitsio -lcurl# 测试样例 https://www.cv.nrao.edu/~sransom/Parkes_70cm_PSR.fits./cfitsiotest Parkes_70cm_PSR.fits zlib1./configure --prefix=/es01/yeesuan/yeesuan003/software/zlib 123export ZLIB=/es01/yeesuan/yeesuan003/software/zlibexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/zlib/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/zlib/include libpng1./configure --prefix=/es01/yeesuan/yeesuan003/software/libpng LDFLAGS=&quot;-L/es01/yeesuan/yeesuan003/software/zlib/lib -lz&quot; 1234export LIBPNG=/es01/yeesuan/yeesuan003/software/libpngexport PATH=/es01/yeesuan/yeesuan003/software/libpng/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/software/libpng/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/software/libpng/include X11 1&gt;./configure --prefix=/es01/yeesuan/yeesuan003/software/X11 报错缺少pixman 12&gt;&gt;wget https://gitlab.freedesktop.org/pixman/pixman/-/archive/master/pixman-master.tar.gz&gt;&gt;./configure --prefix=/es01/yeesuan/yeesuan003/software/pixman 报错缺少autoconf 123&gt;&gt;&gt;wget http://mirrors.kernel.org/gnu/autoconf/autoconf-latest.tar.gz&gt;&gt;&gt;./configure --prefix=/es01/yeesuan/yeesuan003/software/autoconf&gt;&gt;&gt;export PATH=/es01/yeesuan/yeesuan003/software/autoconf/bin$&#123;PATH:+:$&#123;PATH&#125;&#125; 最后的解决办法：在另一台电脑上yum install x11，然后把&#x2F;usr&#x2F;lib64&#x2F;X11文件打包拷贝过来 presto-c配置环境变量 1234export PRESTO=/es01/yeesuan/yeesuan003/source/presto-4.0export PYTHONPATH=/es01/yeesuan/yeesuan003/source/presto-4.0/lib/pythonexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/es01/yeesuan/yeesuan003/source/presto-4.0/libexport C_INCLUDE_PATH=$C_INCLUDE_PATH:/es01/yeesuan/yeesuan003/source/presto-4.0/include libpgplot.so:undefined123456# 尝试更换PGPLOTINC与PGPLOTLINK，使用源码编译安装或spack安装# Include and link information for PGPLOT v5.X (including shared libs!)# Typically you need to have your PGPLOT_DIR environment variable setPGPLOTINC = -I/es01/yeesuan/yeesuan003/software/pgplot/includePGPLOTLINK = -L/es01/yeesuan/yeesuan003/software/pgplot/lib -lcpgplot -lpgplot $(X11LINK) $(PNGLINK) slalib 报错(未解决,但是编译成功了)123456789101112131415161718192021222324252627282930tps2c.f(1): remark #15009: sla_tps2c_ has been targeted for automatic cpu dispatchtpv2c.f(1): remark #15009: sla_tpv2c_ has been targeted for automatic cpu dispatchue2pv.f(1): remark #15009: sla_ue2pv_ has been targeted for automatic cpu dispatchunpcd.f(1): remark #15009: sla_unpcd_ has been targeted for automatic cpu dispatchv2tp.f(1): remark #15009: sla_v2tp_ has been targeted for automatic cpu dispatchvdv.f(1): remark #15009: sla_vdv_ has been targeted for automatic cpu dispatchvn.f(1): remark #15009: sla_vn_ has been targeted for automatic cpu dispatchvxv.f(1): remark #15009: sla_vxv_ has been targeted for automatic cpu dispatchxy2xy.f(1): remark #15009: sla_xy2xy_ has been targeted for automatic cpu dispatchzd.f(1): remark #15009: sla_zd_ has been targeted for automatic cpu dispatchgresid.F(2): remark #15009: sla_gresid_ has been targeted for automatic cpu dispatchrm slalib/sla_test.ocd slalib ; mpiifort -shared -o /es01/yeesuan/yeesuan003/source/presto-4.0/lib/libsla.so -fno-second-underscore *.oifort: command line warning #10006: ignoring unknown option &#x27;-fno-second-underscore&#x27;cd slalib ; mpiifort -o sla_test sla_test.f -fno-second-underscore -L/es01/yeesuan/yeesuan003/source/presto-4.0/lib -lslaifort: command line warning #10006: ignoring unknown option &#x27;-fno-second-underscore&#x27;sla_test.f(901): remark #15009: t_bear_ has been targeted for automatic cpu dispatchsla_test.f(4397): remark #15009: t_planet_ has been targeted for automatic cpu dispatchsla_test.f(5561): remark #15009: t_sep_ has been targeted for automatic cpu dispatchsla_test.f(5770): remark #15009: t_svd_ has been targeted for automatic cpu dispatchsla_test.f(6205): remark #15009: t_vecmat_ has been targeted for automatic cpu dispatchslalib/sla_test sla_GMSTA test fails: expected = 3.907497135648731579 actual = 3.907497135670340072 sla_PA test zenith fails: expected = 0.000000000000000000 actual = 3.141592653589793116 SLALIB validation failed!make: *** [slalib] Error 1 undefined reference to ‘cpg***’ &amp;&amp; undefined reference to &#96;XSync’（未解决）1234567891011121314151617181920mpif90 -g -fPIC -Wl,-rpath,/es01/yeesuan/yeesuan003/source/presto-4.0/lib -fopenmp -o /es01/yeesuan/yeesuan003/source/presto-4.0/bin/psrorbit powerplot.o xyline.o psrorbit.o -L/es01/yeesuan/yeesuan003/software/cfitsio/lib -L/es01/yeesuan/yeesuan003/software/curl/lib -lm -lcfitsio -lcurl -L/es01/yeesuan/yeesuan003/source/presto-4.0/lib -lpresto -L/es01/yeesuan/yeesuan003/software/fftw/lib -L/es01/yeesuan/yeesuan003/software/fftw3d/lib -lfftw3f -lfftw3 -L/es01/yeesuan/yeesuan003/software/pgplot/lib -lpgplot -L/usr/lib64/X11 -L/es01/yeesuan/yeesuan003/software/libpng/lib -lm/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: psrorbit.o: in function `main&#x27;:/es01/yeesuan/yeesuan003/source/presto-4.0/src/psrorbit.c:205: undefined reference to `cpgend&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: powerplot.o: in function `powerplot&#x27;:/es01/yeesuan/yeesuan003/source/presto-4.0/src/powerplot.c:27: undefined reference to `cpgenv&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/source/presto-4.0/src/powerplot.c:30: undefined reference to `cpgscf&#x27;············/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/software/pgplot/lib/libpgplot.so: undefined reference to `XGetSelectionOwner&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/software/pgplot/lib/libpgplot.so: undefined reference to `XCloseDisplay&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/software/pgplot/lib/libpgplot.so: undefined reference to `XSync&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/software/pgplot/lib/libpgplot.so: undefined reference to `XMapRaised&#x27;/es01/jnist/software/common/linux-centos7-haswell/gcc-4.8.5/binutils-2.37-7zolnrfrz4erct4f54lkgdpne3p6xj3z/bin/ld: /es01/yeesuan/yeesuan003/software/pgplot/lib/libpgplot.so: undefined reference to `XPutImage&#x27;collect2: error: ld returned 1 exit statusmake: *** [psrorbit] Error 1 尝试使用spack load pgplot，无效 尝试更换pgplot版本（原版本pgplot5.2），更换为552版本，无效 尝试从源码编译x11，无效，找不到X11/Xos.h 测试123456789101112131415161718192021222324252627282930313233343536373839404142(base) [yeesuan003@spack bin]$ ./readfile [-page] [-byte] [-b] [-float] [-f] [-double] [-d] [-fcomplex] [-fc] [-dcomplex] [-dc] [-short] [-s] [-int] [-i] [-long] [-l] [-rzwcand] [-rzw] [-bincand] [-bin] [-position] [-pos] [-pkmb] [-bcpm] [-wapp] [-spigot] [-filterbank] [-psrfits] [-fortran] [-index [index]] [-nph nph] [--] file Reads raw data from a binary file and displays it on stdout. -page: Paginate the output like &#x27;more&#x27; -byte: Raw data in byte format -b: Raw data in byte format -float: Raw data in floating point format -f: Raw data in floating point format -double: Raw data in double precision format -d: Raw data in double precision format -fcomplex: Raw data in float-complex format -fc: Raw data in float-complex format -dcomplex: Raw data in double-complex format -dc: Raw data in double-complex format -short: Raw data in short format -s: Raw data in short format -int: Raw data in integer format -i: Raw data in integer format -long: Raw data in long format -l: Raw data in long format -rzwcand: Raw data in rzw search candidate format -rzw: Raw data in rzw search candidate format -bincand: Raw data in bin search candidate format -bin: Raw data in bin search candidate format -position: Raw data in position struct format -pos: Raw data in position struct format -pkmb: Raw data in Parkes Multibeam format -bcpm: Raw data in BCPM format -wapp: Raw data in WAPP format -spigot: Raw data in Spigot Card format -filterbank: Raw data in SIGPROC filterbank format -psrfits: Raw data in PSRFITS format -fortran: Raw data was written by a fortran program -index: The range of objects to display 0...2 int values between -1 and oo default: `0&#x27; ` -1&#x27; -nph: 0th FFT bin amplitude (for &#x27;RZW&#x27; data) 1 double value default: `1.0&#x27; file: Input data file name. 1 value version: 12Mar10 Anaconda1wget https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh pySLALIB1wget https://files.pythonhosted.org/packages/3e/e1/e731f0b69d9145faa2aa321a82ff27d6da1d929ac02d7206ca5ae6ec23e3/pySLALIB-1.0.4.tar.gz presto-python修改setup.py 12345678910111213141516171819202122232425262728ppgplot_libraries = [&quot;gfortran&quot;, &quot;cpgplot&quot;, &quot;pgplot&quot;, &quot;X11&quot;, &quot;png&quot;, &quot;m&quot;]ppgplot_library_dirs = [&quot;/usr/lib64&quot;, &quot;/es01/jnist/software/common/linux-centos7-skylake_avx512/gcc-8.5.0/libx11-1.7.0-2ovdqwa5f77pnonzmft6ttzmblxxibbe/lib&quot;]presto_libraries = [&quot;presto&quot;, &quot;fftw3&quot;, &quot;m&quot;]presto_library_dirs = [&quot;/es01/yeesuan/yeesuan003/software/fftw/lib&quot;, &quot;/es01/jnist/software/common/linux-centos7-skylake_avx512/gcc-8.5.0/libx11-1.7.0-2ovdqwa5f77pnonzmft6ttzmblxxibbe/lib&quot;]#### ~Lines~ ######### ~Lines~ ######### ~Lines~ ######### ~Lines~ ######### ~Lines~ #####setup(name=&quot;presto&quot;, version=version, install_requires=[&#x27;numpy&#x27;, &#x27;future&#x27;, &#x27;six&#x27;, &#x27;scipy&#x27;, &#x27;matplotlib&#x27;, &#x27;astropy&#x27;, &#x27;pyslalib&#x27;], # scripts=scripts, description=&quot;Python interfaces to PGPLOT and PRESTO&quot;, author=&quot;Scott Ransom (ppgplot from Nick Patavlis)&quot;, author_email=&quot;sransom@nrao.edu&quot;, url=&quot;https://github.com/scottransom/presto&quot;, packages=[&#x27;presto&#x27;, &#x27;presto.ppgplot&#x27;, &#x27;presto.presto&#x27;, &#x27;presto.singlepulse&#x27;], package_dir=&#123;&#x27;presto.ppgplot&#x27;: &#x27;python/ppgplot_src&#x27;, &#x27;presto.presto&#x27;: &#x27;python/presto_src&#x27;, &#x27;presto&#x27;: &#x27;python/presto&#x27;, &#x27;presto.singlepulse&#x27;: &#x27;python/presto/singlepulse&#x27;, &#125;, package_data=&#123;&#x27;presto&#x27;: [&#x27;*.json&#x27;]&#125;, ext_modules=[ext_ppgplot, ext_presto, ext_fftfit]) 执行以下命令安装 1CC=&#x27;gcc -std=c99&#x27; python3 setup.py install --home=$&#123;PRESTO&#125; 环境变量配置 1export export PYTHONPATH=/es01/yeesuan/yeesuan003/source/presto-4.0/lib/python/presto-4.0-py3.9-linux-x86_64.egg 测试 123456789101112131415161718192021222324(base) [yeesuan003@spack presto-4.0]$ cd bin/(base) [yeesuan003@spack bin]$ ./DDplan.py usage: DDplan.py [options] [raw PSRFITS or filterbank file] [-h, --help] : Display this help [-o outfile, --outfile=outfile] : Output .eps plot file (default is xwin) [-l loDM, --loDM=loDM] : Low DM to search (default = 0 pc cm-3) [-d hiDM, --hiDM=HIDM] : High DM to search (default = 1000 pc cm-3) [-f fctr, --fctr=fctr] : Center frequency (default = 1400MHz) [-b BW, --bw=bandwidth] : Bandwidth in MHz (default = 300MHz) [-n #chan, --numchan=#chan] : Number of channels (default = 1024) [-k blocklen, --blocklen=#spec] : Spectra per subint (for downsampling) (default = 1024) [-c cDM, --cohdm=cDM] : Coherent DM in each chan (default = 0.0) [-t dt, --dt=dt] : Sample time (s) (default = 0.000064 s) [-s subbands, --subbands=nsub] : Number of subbands (default = #chan) [-r resolution, --res=res] : Acceptable time resolution (ms) [-w, --write] : Write a dedisp.py file for the plan The program generates a good plan for de-dispersing raw data. It trades a small amount of sensitivity in order to save computation costs. It will determine the observation parameters from the raw data file if it exists. fitsio地址：https://github.com/esheldon/fitsio 解压并进入cfitsio3490目录，执行./configure,make,make install 进入上层目录，执行python3 setup.py install mpi4py安装 1pip3 install mpi4py 测试 12345678910# mpi_helloworld.pyfrom mpi4py import MPIcomm = MPI.COMM_WORLDsize = comm.Get_size()rank = comm.Get_rank()node_name = MPI.Get_processor_name() # get the name of the nodeprint(&#x27;Hello world from process &#123;0&#125; at &#123;1&#125;.&#x27;.format(rank, node_name)) 1mpiexec -n 3 python3 test.py presto-c的spack安装代码package.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from spack import *from os import *class PrestoC(MakefilePackage): &quot;&quot;&quot;presto-c By lhxone&quot;&quot;&quot; # FIXME: Add a proper url for your package&#x27;s homepage here. homepage = &quot;https://blog.lhxone.com&quot; url = &quot;file:///es01/yeesuan/yeesuan003/source/presto-c.tar.gz&quot; # FIXME: Add a list of GitHub accounts to # notify when the package is updated. # maintainers = [&#x27;github_user1&#x27;, &#x27;github_user2&#x27;] version(&#x27;1.2.4&#x27;, &#x27;c7d69f3eb8680a54541d3525fbe46159539037aa6a5fb5ae59fb210a9e0034b1&#x27;) variant(&#x27;mpi&#x27;, default=False, description=&#x27;Enable MPI&#x27;) depends_on(&#x27;libx11&#x27;) depends_on(&#x27;cfitsio&#x27;) depends_on(&#x27;pgplot&#x27;) depends_on(&#x27;libpng&#x27;) depends_on(&#x27;fftw&#x27;) depends_on(&#x27;curl&#x27;) depends_on(&#x27;mpi&#x27;, when = &#x27;+mpi&#x27;) depends_on(&#x27;gglib&#x27;, type=(&#x27;build&#x27;)) def setup_build_environment(self, env): env.append_path(&#x27;LD_LIBRARY_PATH&#x27;, self.stage.source_path + &#x27;/lib&#x27;) env.set(&#x27;PRESTO&#x27;, self.stage.source_path) def edit(self, spec, prefix): with working_dir(&#x27;src&#x27;): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(r&#x27;^\\s*X11LINK\\s*:=.*&#x27;, &#x27;X11LINK := -L&#x27; + spec[&#x27;libx11&#x27;].prefix.lib +&#x27; -lX11&#x27;) makefile.filter(r&#x27;^\\s*PNGLINK\\s*:=.*&#x27;, &#x27;PNGLINK := -L&#x27; + spec[&#x27;libpng&#x27;].prefix.lib + &#x27; -lpng&#x27;) makefile.filter(r&#x27;^\\s*PGPLOTINC\\s*=.*&#x27;, &#x27;PGPLOTINC = -I&#x27; + spec[&#x27;pgplot&#x27;].prefix.include) makefile.filter(r&#x27;^\\s*PGPLOTLINK\\s*=.*&#x27;, &#x27;PGPLOTLINK = -L&#x27; + spec[&#x27;pgplot&#x27;].prefix.lib + &#x27; -lcpgplot -lpgplot $(X11LINK) $(PNGLINK)&#x27;) # makefile.filter(r&#x27;^\\s*FFTINC\\s*:=.*&#x27;, &#x27;FFTINC := -I&#x27; + spec[&#x27;fftw&#x27;].prefix.include) # makefile.filter(r&#x27;^\\s*FFTLINK\\s*:=.*&#x27;, &#x27;FFTLINK := -L&#x27; + spec[&#x27;fftw&#x27;].prefix.lib + &#x27; -lfftw3 -lfftw3f&#x27;) makefile.filter(r&#x27;^\\s*FFTINC\\s*:=.*&#x27;, &#x27;FFTINC := -I/es01/yeesuan/yeesuan003/software/fftw/include&#x27;) makefile.filter(r&#x27;^\\s*FFTLINK\\s*:=.*&#x27;, &#x27;FFTLINK := -L/es01/yeesuan/yeesuan003/software/fftw/lib -lfftw3 -lfftw3f&#x27;) # makefile.filter(r&#x27;^\\s*CFITSIOINC\\s*:=.*&#x27;, &#x27;CFITSIOINC := -I/es01/yeesuan/yeesuan003/software/cfitsio/include&#x27;) # makefile.filter(r&#x27;^\\s*CFITSIOLINK\\s*:=.*&#x27;, &#x27;CFITSIOLINK := -L/es01/yeesuan/yeesuan003/software/cfitsio/lib &#x27;) makefile.filter(r&#x27;^\\s*CFITSIOINC\\s*:=.*&#x27;, &#x27;CFITSIOINC := -I&#x27; + spec[&#x27;cfitsio&#x27;].prefix.include) makefile.filter(r&#x27;^\\s*CFITSIOLINK\\s*:=.*&#x27;, &#x27;CFITSIOLINK := -L&#x27; + spec[&#x27;cfitsio&#x27;].prefix.lib + &#x27; -L&#x27; + spec[&#x27;curl&#x27;].prefix.lib + &#x27; -lm -lcfitsio -lcurl&#x27;) #如果使用spec[&#x27;glib&#x27;]会报错 # ==&gt; [2022-04-07-11:11:19.715615] Releasing read lock on fftw-3.3.10-sm7gxt7rfyvosnyv5nztr2ynnai2uv3d # ==&gt; [2022-04-07-11:11:19.716372] Error: presto-c-1.2.3-y6i7lvlmsuxopndcmd5voa5i75dkqwu7: Package was not installed # ==&gt; [2022-04-07-11:11:19.716511] InstallError: Installation request failed. Refer to reported errors for failing package(s). # ==&gt; [2022-04-07-11:11:19.716556] Error: Installation request failed. Refer to reported errors for failing package(s). makefile.filter(r&#x27;^\\s*GLIBINC\\s*:=.*&#x27;, &#x27;GLIBINC := -I&#x27; + spec[&#x27;gglib&#x27;].prefix.include + &#x27;/glib-2.0&#x27;) makefile.filter(r&#x27;^\\s*GLIBLINK\\s*:=.*&#x27;, &#x27;GLIBLINK := -L&#x27; + spec[&#x27;gglib&#x27;].prefix.lib + &#x27; -lglib-2.0&#x27;) # makefile.filter(r&#x27;^\\s*GLIBINC\\s*:=.*&#x27;, &#x27;GLIBINC := -I/es01/yeesuan/yeesuan003/software/glib/include/glib-2.0&#x27;) # makefile.filter(r&#x27;^\\s*GLIBLINK\\s*:=.*&#x27;, &#x27;GLIBLINK := -L/es01/yeesuan/yeesuan003/software/glib/lib -lglib-2.0&#x27;) # Enable mpi if &#x27;+mpi&#x27; in self.spec: makefile.filter(&#x27;(mpicc)&#x27;, &#x27;mpiicc&#x27;) def build(self, spec, prefix): with working_dir(&#x27;src&#x27;): make(&#x27;makewisdom&#x27;) make(&#x27;prep&#x27;) make() if &#x27;+mpi&#x27; in self.spec: make(&#x27;mpi&#x27;) def install(self, spec, prefix): mkdir(prefix.bin) with working_dir(&#x27;bin&#x27;): install(&#x27;*&#x27;, prefix.bin) mkdir(prefix.lib) with working_dir(&#x27;lib&#x27;): install(&#x27;*&#x27;, prefix.lib) mkdir(prefix.include) with working_dir(&#x27;include&#x27;): install(&#x27;*&#x27;, prefix.include)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"presto-c","slug":"presto-c","permalink":"http://example.com/tags/presto-c/"}]},{"title":"FVCOM编译&测试","slug":"FVCOM编译-测试","date":"2022-03-08T06:24:38.000Z","updated":"2023-08-25T03:24:45.436Z","comments":true,"path":"2022/03/08/FVCOM编译-测试/","link":"","permalink":"http://example.com/2022/03/08/FVCOM%E7%BC%96%E8%AF%91-%E6%B5%8B%E8%AF%95/","excerpt":"FVCOM编译&amp;测试FVCOM介绍： FVCOM 是由 UMASSD-WHOI 联合开发的预测性、非结构化网格、有限体积、自由表面、3-D 原始方程沿海海洋环流模型。","text":"FVCOM编译&amp;测试FVCOM介绍： FVCOM 是由 UMASSD-WHOI 联合开发的预测性、非结构化网格、有限体积、自由表面、3-D 原始方程沿海海洋环流模型。该模型由动量、连续性、温度、盐度和密度方程组成，并使用湍流闭合子模型进行物理和数学闭合。水平网格由非结构化三角形单元组成，不规则底部使用广义地形跟踪坐标呈现。由德国 Burchard 研究小组（Burchard，2002 年）开发的通用海洋湍流模型 (GOTM) 已添加到 FVCOM 中，以提供可选的垂直湍流闭合方案。FVCOM 是通过在非结构化三角形网格上以控制方程的积分形式进行的二阶精确离散通量计算来数值求解的。这种方法结合了有限元方法（网格灵活性）和有限差分方法（数值效率和代码简单性）的最佳特性，并提供了更好的局部和全局动量、质量、盐、热和示踪剂守恒的数值表示. 除了非结构化网格提供的拓扑灵活性和编码结构的简单性之外，FVCOM 准确求解标量守恒方程的能力使 FVCOM 非常适合许多沿海和跨学科科学应用。 编译前准备安装HDF5源码地址为https://s3.amazonaws.com/hdf-wordpress-1/wp-content/uploads/manual/HDF5/HDF5_1_10_5/source/hdf5-1.10.5.tar.gz,使用wget下载并解压源码 123wget https://s3.amazonaws.com/hdf-wordpress-1/wp-content/uploads/manual/HDF5/HDF5_1_10_5/source/hdf5-1.10.5.tar.gztar -xvf hdf5-1.10.5.tar.gzcd hdf5-1.10.5 执行以下命令进行配置、编译及安装 123./configure --prefix=/path/to/install/HDF5 --enable-fortran --enable-parallel CC=mpicc FC=mpif90 CXX=mpicxxmake -jmake install 安装NetCDF-C在安装NetCDF-C时,使用4.7.0版本的安装包报错,在GitHub上查到issue,更换最新版本解决 12checking whether byte range support is enabled... noconfigure: error: curl required for byte range support. Install curl or build without --enable-byterange. 源码地址为https://github.com/Unidata/netcdf-c/archive/refs/tags/v4.8.1.tar.gz,使用wget下载并解压源码 123wget https://github.com/Unidata/netcdf-c/archive/refs/tags/v4.8.1.tar.gztar -zxvf netcdf-c-4.8.1.tar.gzcd netcdf-c-4.8.1 执行以下命令进行配置、编译及安装 123./configure --prefix=/path/to/NETCDF LDFLAGS=&quot;-L$HDF5/lib&quot; CPPFLAGS=&quot;-I$HDF5/include&quot; CC=mpicc --disable-dapmake -jmake install 编辑环境变量 1234vim ~/.bashrcexport PATH=&quot;/path/to/NETCDF/bin:$PATH&quot;export LD_LIBRARY_PATH=&quot;/path/to/NETCDF/lib:$LD_LIBRARY_PATH &quot;export NETCDF=&quot;/path/to/NETCDF&quot; 安装NetCDF-Fortran源码地址为https://github.com/Unidata/netcdf-fortran/archive/refs/tags/v4.5.4.tar.gz,使用wget下载并解压 123wget https://github.com/Unidata/netcdf-fortran/archive/refs/tags/v4.5.4.tar.gztar -xzvf netcdf-fortran-4.5.4.tar.gzcd netcdf-fortran-4.5.4.tar.gz 执行以下命令进行配置 123./configure --prefix=/path/to/NETCDF CPPFLAGS=&quot;-I$HDF5/include -I$NETCDF/include&quot; LDFLAGS=&quot;-L$HDF5/lib -L$NETCDF/lib&quot; CC=mpicc FC=mpif90 F77=mpif90make -jmake install 编译FVCOM主程序获取安装包源码地址为http://fvcom.smast.umassd.edu/releases/fvcom-4.1.tar.gz,将其下载到本地并解压 1234wget http://fvcom.smast.umassd.edu/releases/fvcom-4.1.tar.gzmv fvcom-4.1.tar.gz /path/to/FVCOMtar -xzvf fvcom-4.1.tar.gzcd FVCOM4.1 配置若要使用Estuary算例,则使用Examples/Estuary/make.inc_example;若要使用Inlet算例,则应使用Examples/Inlets/make.inc_example,在确认样例之后,将所选的模版文件复制到FVCOM_source之下. 12345# 复制模版文件(以Estuary为例)cp Examples/Estuary/make.inc_example FVCOM_source/make.inc# 创建软连接ln -sf FVCOM_source/make.inc ./ 编辑make.inc 12345678910111213141516171819202122232425262728############# make.inc #################################################################################################### TOPDIR = /path/to/FVCOM/FVCOM4.1/FVCOM_source 51 TOPDIR = /es01/yeesuan/yeesuan003/lhxone-test/software/FVCOM/FVCOM4.1/FVCOM_source###################################################################################### 79 LIBDIR = -L$(INSTALLDIR)/lib -L../METIS_source/metis -L./libs/julian 80 INCDIR = -I$(INSTALLDIR)/include -I../METIS_source/metis -I./libs/julia###################################################################################### 97 IOLIBS = -L/es01/yeesuan/yeesuan003/lhxone-test/software/NETCDF/lib -L/es01/yeesuan/yeesuan003/lhxone-test/software/HDF5/lib -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz -lm######################################################################################532 #--------------------------------------------------------------------------533 # Intel/MPI Compiler Definitions (SMAST)534 #--------------------------------------------------------------------------535 CPP = /usr/bin/cpp536 COMPILER = -DIFORT537 CC = mpiicc538 CXX = mpiicpc539 CFLAGS = -O3540 FC = mpiifort 编译Metis库执行以下命令编译metis库 12345678cd /path/to//FVCOM/FVCOM4.1/METIS_sourcetar -zxvf metis.tgzcd metismkdir -p /path/to/FVCOM/FVCOM4.1/FVCOM_source/libs/install/libmkdir -p /path/to/FVCOM/FVCOM4.1/FVCOM_source/libs/install/includemkdir -p /path/to/FVCOM/FVCOM4.1/FVCOM_source/libs/install/binmake -jmake install 编译julian库执行以下命令编译julian库 12345cd /path/to/FVCOM4.1/FVCOM_source/libstar -zxvf julian.tgzcd julianmake -jmake install 安装主程序执行以下命令以编译安装FVCOM主程序 123456cd /path/to/FVCOM/FVCOM4.1/FVCOM_sourcevim swmod2.F# 修改104行内容104 !!!!$OMP&amp; KM_WAM, KM01, SIGM_10, SIGM01):wq!vim mod_newinp.F 在mod_newinp.F中修改如下内容 123456789101112131415161718192021222324252627! 第一个&quot;contains&quot;语句添加如下内容。! line_50contains Character(Len=256) Function N_Fmt(c, n) Character(Len=*), Intent(IN) :: c Integer, Intent(IN) :: n integer :: i, j character(len=16) :: cn i = index(c, &#x27;&lt;&#x27;) j = index(c, &#x27;&gt;&#x27;) write (cn, &#x27;(g0)&#x27;) n N_Fmt = c(:i - 1)//Trim(adjustL(cn))//c(j + 1:) End Function N_Fmt!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! line_352write(*,N_Fmt(&#x27;(A20,&lt;size&gt;F10.4)&#x27;,SIZE))trim(argname)//&#x27;: &#x27;,fval(1:SIZE)! line_421write(*,N_Fmt(&#x27;(A20,&lt;size&gt;I10)&#x27;,SIZE))trim(argname)//&#x27;: &#x27;,ival(1:SIZE)! line_494write(*,N_Fmt(&#x27;(A20,&lt;size&gt;L10)&#x27;,SIZE))trim(argname)//&#x27;: &#x27;,cval(1:SIZE)! line_567write(*,N_Fmt(&#x27;(A20,&lt;size&gt;A10)&#x27;,SIZE))trim(argname)//&#x27;: &#x27;,sval(1:SIZE) 执行以下命令以修改“&#x3D;&#x3D;”为“.eqv.”,修改“&#x2F;&#x3D;”为“.neqv” 1234sed -i &#x27;s/\\/=\\.TRUE\\./\\.neqv\\.\\.TRUE\\./g&#x27; mod_scal.Fsed -i &#x27;s/==\\.TRUE/\\.eqv\\.\\.TRUE/g&#x27; internal_step.Fsed -i &#x27;s/==\\.FALSE\\./\\.eqv\\.\\.FALSE\\./g&#x27; adv_t.Fsed -i &#x27;s/==\\.FALSE\\./\\.eqv\\.\\.FALSE\\./g&#x27; adv_s.F 修改完成后执行make命令,即可在当前目录下看到fvcom 123makefind fvcomfvcom 测试运算复制算例到测试目录1234mkdir -p /path/to/FVCOM/testcd /path/to/FVCOM/testcp cp -r /path/to/FVCOM/FVCOM4.1/Examples/Estuary/ ./cd Estuary/run 运行算例12# 在当前目录下生成tst_0001.nc结果文件mpirun -n 24 --bind-to core /path/to/fvcom --casename=tst","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"FVCOM","slug":"FVCOM","permalink":"http://example.com/tags/FVCOM/"}]},{"title":"基于spack的blas编译","slug":"基于spack的blas编译","date":"2022-03-07T02:27:51.000Z","updated":"2023-08-25T03:24:57.595Z","comments":true,"path":"2022/03/07/基于spack的blas编译/","link":"","permalink":"http://example.com/2022/03/07/%E5%9F%BA%E4%BA%8Espack%E7%9A%84blas%E7%BC%96%E8%AF%91/","excerpt":"直接编译blas首先从netlib官网下载源码,然后进入blas目录,修改make.inc文件最后一行,将其改为BLASLIB = libblas.a","text":"直接编译blas首先从netlib官网下载源码,然后进入blas目录,修改make.inc文件最后一行,将其改为BLASLIB = libblas.a 1234wget http://www.netlib.org/blas/blas-3.10.0.tgztar xzvf blas-3.10.0.tgzcd BLAS-3.10.0vim make.inc 修改完成后,执行make all即可在当前目录下编译生成libblas.a 123make allfind libblas.a# libblas.a 使用spack脚本编译blas基本命令 spack create [-n name] [-t TEMPLATE, --template TEMPLATE] [url] 创建一个以[template]为模版的包,并生成对应目录和package.py spack info [name] 显示一个包的信息 spack edit [name] 快速编辑某个包目录下的package.py文件 安装某个包,-v参数可以显示安装编译过程的详细日志 开始编译首先创建一个包,并编辑package.py文件.值得注意的是,包名不可以为blas,这会与现有规则冲突($spack/etc/spack/defaults/packages.yaml) 12# 执行此命令会在创建完成后进入编辑package.py,加入--skip-editor以跳过spack create netlib-blas 1234567891011121314151617181920212223# 在package.py中修改以下内容from spack import *# netlib-blas -&gt; NetlibBlas# 3dm -&gt; _3dmclass NetlibBlas(MakefilePackage): &quot;&quot;&quot;FIXME: Put a proper description of your package here.&quot;&quot;&quot; homepage = &quot;https://www.example.com&quot; # 指定url、版本以及哈希值 url = &quot;file:///es01/yeesuan/yeesuan003/mirror/blasblas-3.10.0.tgz&quot; version(&#x27;3.10.0&#x27;, sha256=&#x27;2e360d99c9bdc8407a61888c40aa853fb4219420ebb8264db486cb8860468ab3&#x27;) def edit(self, spec, prefix): # 文件操作函数filter_file(regex, repl, *filenames, **kwargs) # 使用正则表达式修改编译生成的文件名称 makefile = FileFilter(&#x27;make.inc&#x27;) makefile.filter(r&#x27;^\\s*BLASLIB\\s*=.*&#x27;, &#x27;BLASLIB = libblas.a&#x27;) def install(self, spec, prefix): # 生成lib目录 mkdir(prefix.lib) install(&quot;libblas.a&quot;,prefix.lib) 编辑完成后,执行spack install netlib-blas 1234567891011121314151617[yeesuan003@spack ~]$ spack install netlib-blas==&gt; Installing netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4==&gt; No binary for netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4 found: installing from source==&gt; Using cached archive: /es01/yeesuan/yeesuan003/lhxone-test/spack/var/spack/cache/_source-cache/archive/2e/2e360d99c9bdc8407a61888c40aa853fb4219420ebb8264db486cb8860468ab3.tgz==&gt; No patches needed for netlib-blas==&gt; netlib-blas: Executing phase: &#x27;edit&#x27;==&gt; netlib-blas: Executing phase: &#x27;build&#x27;==&gt; netlib-blas: Executing phase: &#x27;install&#x27;==&gt; netlib-blas: Successfully installed netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4 Fetch: 0.00s. Build: 1.08s. Total: 1.09s.[+] /es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-haswell/gcc-4.8.5/netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4[yeesuan003@spack ~]$ tree /es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-haswell/gcc-4.8.5/netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4/es01/yeesuan/yeesuan003/lhxone-test/spack/software/linux-centos7-haswell/gcc-4.8.5/netlib-blas-3.10.0-lvh47amv4vn23kti7cwdkbe4izugjsr4└── lib └── libblas.a1 directory, 1 file 备注依赖1depends_on(&#x27;gmake&#x27;, type=&#x27;build&#x27;) 环境变量123def edit(self, spec, prefix): env[&#x27;PREFIX&#x27;] = prefix env[&#x27;BLASLIB&#x27;] = spec[&#x27;blas&#x27;].libs.ld_flags 编辑Makefile1234567def edit(self, spec, prefix): makefile = FileFilter(&#x27;Makefile&#x27;) makefile.filter(r&#x27;^\\s*CC\\s*=.*&#x27;, &#x27;CC = &#x27; + spack_cc) makefile.filter(r&#x27;^\\s*CXX\\s*=.*&#x27;, &#x27;CXX = &#x27; + spack_cxx) makefile.filter(r&#x27;^\\s*F77\\s*=.*&#x27;, &#x27;F77 = &#x27; + spack_f77) makefile.filter(r&#x27;^\\s*FC\\s*=.*&#x27;, &#x27;FC = &#x27; + spack_fc) 手动安装1234def install(self, spec, prefix): mkdir(prefix.bin) install(&#x27;foo&#x27;, prefix.bin) install_tree(&#x27;lib&#x27;, prefix.lib)","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]},{"title":"vasp编译&测试","slug":"vasp编译-测试","date":"2022-03-02T05:55:45.000Z","updated":"2023-08-25T03:25:13.389Z","comments":true,"path":"2022/03/02/vasp编译-测试/","link":"","permalink":"http://example.com/2022/03/02/vasp%E7%BC%96%E8%AF%91-%E6%B5%8B%E8%AF%95/","excerpt":"vasp编译&amp;测试vasp介绍： 原子尺度材料模拟的计算机程序包，更知名为VASP，","text":"vasp编译&amp;测试vasp介绍： 原子尺度材料模拟的计算机程序包，更知名为VASP，是用于执行从头计算量子力学的分子动力学(MD)使用Vanderbilt泛函，或投增强波的方法和一个平面波基组的程序包。理论基础是密度泛函理论(DFT)，但该程序还允许使用后-DFT更正，如混合函数混合密度泛函理论和哈特里–福克交换，多体扰动理论(GW近似)和随机相位近似方法内的动态电子相关。 编译前准备 执行以下命令以确保环境中含有icc,icpc,mpiifort等 1234spack load openmpi@4.1.1spack load intel-oneapi-mpi@2021.4.0%gcc@4.8.5spack load intel-mpi@2019.10.317%gcc@4.8.5spack load intel-parallel-studio@cluster.2019.5 源码在/es01/jnist/mirror下可以找到,本次安装的版本为5.4.4 mkl(Math Kernel Library)其地址在/es01/jnist/software/general/linux-centos7-cascadelake/gcc-10.2.0/intel-parallel-studio-cluster.2018.1-yn56mgyhtg5knpfmpgtcax3o3wfonhhp/compilers_and_libraries_2018.1.163/linux/mkl,在使用前需载入intel-parallel-studio@cluster.2019.5 并行fftw这里选择自行编译并行fftw 将fftw源码解压到/es01/yeesuan/yeesuan003/source/之下,执行以下命令进行编译并行fftw 12345./configure --prefix=/es01/yeesuan/yeesuan003/lhxone-test/software/fftw-3.3.9 CC=icc F77=ifort MPICC=mpiicc --enable-mpimake -j 30make installcd /es01/yeesuan/yeesuan003/lhxone-test/softwaremv fftw-3.3.9 fftw-mpi 编译获取源码源码在/es01/jnist/mirror下可以找到,本次安装的版本为5.4.4,将源码移到~/source并解压 12cp vasp/vasp.5.4.4.tgz ~/sourcetar xzvf vasp.5.4.4.tgz makefile配置在vasp.5.4.4/arch之下,提供了不同的makefile模版,这里使用makefile.include.linux_intel,并在此基础上对其进行修改 1cp arch/makefile.include.linux_intel makefile.include 在makefile.include中,修改以下路径 123456789101112131415161724 $(MKLROOT) = /es01/jnist/software/general/linux-centos7-cascadelake/gcc-10.2.0/intel-parallel-studio-cluster.2018.1-yn56mgyhtg5knpfmpgtcax3o3wfonhhp/compilers_and_libraries_2018.1.163/linux/mkl25 MKL_PATH = $(MKLROOT)/lib/intel6426 BLAS = -L$(MKL_PATH) -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread27 LAPACK = -L$(MKL_PATH) -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lpthread28 29 30 #BLACS = -L$(MKL_PATH) -lmkl_blacs_openmpi_lp6431 BLACS = -lmkl_blacs_intelmpi_lp6432 33 34 #SCALAPACK = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS)35 SCALAPACK = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS)36 OBJECTS = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o37 38 INCS =-I/es01/yeesuan/yeesuan003/lhxone-test/software/fftw-mpi/include39 40 LLIBS = $(SCALAPACK) $(LAPACK) $(BLAS) 我的makefile.include下载地址 编译完成后,在bin目录下生成vasp_std,vasp_gam以及vasp_ncl. 1234bin├── vasp_gam├── vasp_ncl└── vasp_std 将其添加到环境变量 1234vim ~/.bashrc# vaspexport PATH=&quot;/es01/yeesuan/yeesuan003/source/vasp.5.4.4/bin:$PATH&quot;source ~/.bashrc 测试运行测试样例下载地址 本地运行1234wget http://124.222.217.156/static/file/vasp_suanli.tar.gztar xzvf vasp_suanli.tar.gzcd vasp_suanlivasp_std 使用slurm提交作业这里采用sbatch提交作业的方式,脚本为submit.sh,其内容如下 123456789101112131415cd vasp_suanlivim submit.sh#!/bin/bash#SBATCH -J vasp_job#SBATCH -o vasp_on_slurm_%j.log#SBATCH -e vasp_on_slurm_error_%j.logecho Running on hostsecho Time is `date`echo Directory is $PWDecho This job runs on the following nodes:echo $SLURM_JOB_NODELISTecho Startingvasp_std:wqsbatch -n1 submit.sh 输出日志文件为vasp_on_slurm_381.log,vasp_on_slurm_error_381.log vasp_on_slurm_381.log 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394Running on hostsTime is 2022年 03月 02日 星期三 15:27:23 CSTDirectory is /es01/yeesuan/yeesuan003/vasp_suanliThis job runs on the following nodes:node1Starting running on 1 total cores distrk: each k-point on 1 cores, 1 groups distr: one band on 1 cores, 1 groups using from now: INCAR vasp.5.4.4.18Apr17-6-g9f103f2a35 (build Mar 02 2022 10:43:08) complex POSCAR found type information on POSCAR C H POSCAR found : 2 types and 8 ions scaLAPACK will be used LDA part: xc-table for Pade appr. of Perdew POSCAR, INCAR and KPOINTS ok, starting setup FFT: planning ... WAVECAR not read WARNING: random wavefunctions but no delay for mixing, default for NELMDL prediction of wavefunctions initialized - no I/O entering main loop N E dE d eps ncg rms rms(c)RMM: 1 0.158376549325E+03 0.15838E+03 -0.25387E+03 12 0.538E+02RMM: 2 0.724768511531E+02 -0.85900E+02 -0.98209E+02 12 0.133E+02RMM: 3 0.203902846357E+02 -0.52087E+02 -0.57350E+02 12 0.108E+02RMM: 4 -0.269785606514E+02 -0.47369E+02 -0.32864E+02 12 0.101E+02RMM: 5 -0.402228244268E+02 -0.13244E+02 -0.12484E+02 12 0.730E+01RMM: 6 -0.440000594840E+02 -0.37772E+01 -0.34955E+01 12 0.429E+01RMM: 7 -0.450389920389E+02 -0.10389E+01 -0.10145E+01 12 0.245E+01RMM: 8 -0.453706927154E+02 -0.33170E+00 -0.32172E+00 12 0.140E+01RMM: 9 -0.455134036475E+02 -0.14271E+00 -0.14058E+00 25 0.810E+00RMM: 10 -0.455323634295E+02 -0.18960E-01 -0.18213E-01 28 0.256E+00RMM: 11 -0.455326567164E+02 -0.29329E-03 -0.26452E-03 25 0.296E-01RMM: 12 -0.455326951120E+02 -0.38396E-04 -0.37298E-04 26 0.975E-02 0.106E+01RMM: 13 -0.413835805330E+02 0.41491E+01 -0.75991E+00 24 0.145E+01 0.551E+00RMM: 14 -0.405264166634E+02 0.85716E+00 -0.24824E+00 24 0.803E+00 0.266E+00RMM: 15 -0.403450150777E+02 0.18140E+00 -0.28285E-01 24 0.318E+00 0.295E-01RMM: 16 -0.403393957409E+02 0.56193E-02 -0.30123E-02 24 0.957E-01 0.265E-01RMM: 17 -0.403475645736E+02 -0.81688E-02 -0.92386E-03 24 0.542E-01 0.149E-01RMM: 18 -0.403517032644E+02 -0.41387E-02 -0.15901E-02 24 0.693E-01 0.233E-01RMM: 19 -0.403523808258E+02 -0.67756E-03 -0.94824E-03 24 0.498E-01 0.648E-02RMM: 20 -0.403532027230E+02 -0.82190E-03 -0.20094E-04 24 0.104E-01 0.430E-02RMM: 21 -0.403533437443E+02 -0.14102E-03 -0.38563E-04 24 0.100E-01 0.107E-02RMM: 22 -0.403534062939E+02 -0.62550E-04 -0.37874E-05 24 0.324E-02 0.583E-03RMM: 23 -0.403534085406E+02 -0.22467E-05 -0.56604E-06 23 0.123E-02 0.123E-03RMM: 24 -0.403534159726E+02 -0.74320E-05 -0.23326E-06 18 0.860E-03 0.143E-03RMM: 25 -0.403534159979E+02 -0.25234E-07 -0.23628E-07 17 0.353E-03 1 T= 292. E= -.40167351E+02 F= -.40431391E+02 E0= -.40431391E+02 EK= 0.26404E+00 SP= 0.00E+00 SK= 0.00E+00 bond charge predicted N E dE d eps ncg rms rms(c)RMM: 1 -0.403421091978E+02 0.11307E-01 -0.80579E-01 24 0.774E+00 0.216E-01RMM: 2 -0.403419842052E+02 0.12499E-03 -0.58599E-03 24 0.583E-01 0.140E-01RMM: 3 -0.403417880987E+02 0.19611E-03 -0.27993E-03 24 0.315E-01 0.487E-02RMM: 4 -0.403417097041E+02 0.78395E-04 -0.15132E-04 24 0.776E-02 0.282E-02RMM: 5 -0.403417288527E+02 -0.19149E-04 -0.16732E-04 24 0.709E-02 0.165E-02RMM: 6 -0.403417179833E+02 0.10869E-04 -0.50066E-05 24 0.373E-02 0.484E-03RMM: 7 -0.403417237679E+02 -0.57845E-05 -0.66094E-06 22 0.157E-02 0.408E-03RMM: 8 -0.403417231446E+02 0.62322E-06 -0.11301E-06 17 0.615E-03 2 T= 167. E= -.40267330E+02 F= -.40418524E+02 E0= -.40418524E+02 EK= 0.15119E+00 SP= 0.00E+00 SK= 0.00E+00 bond charge predicted prediction of wavefunctions N E dE d eps ncg rms rms(c)RMM: 1 -0.403217475988E+02 0.19976E-01 -0.20868E-01 24 0.394E+00 0.937E-02RMM: 2 -0.403217564222E+02 -0.88234E-05 -0.12861E-03 24 0.266E-01 0.593E-02RMM: 3 -0.403217118401E+02 0.44582E-04 -0.31401E-04 24 0.112E-01 0.111E-02RMM: 4 -0.403217092852E+02 0.25549E-05 -0.10095E-05 25 0.231E-02 0.729E-03RMM: 5 -0.403217105375E+02 -0.12523E-05 -0.84718E-06 24 0.157E-02 0.320E-03RMM: 6 -0.403217105390E+02 -0.14845E-08 -0.25112E-06 18 0.877E-03 3 T= 206. E= -.40211156E+02 F= -.40397468E+02 E0= -.40397468E+02 EK= 0.18631E+00 SP= 0.00E+00 SK= 0.00E+00 bond charge predicted prediction of wavefunctions N E dE d eps ncg rms rms(c)RMM: 1 -0.403117808886E+02 0.99296E-02 -0.39721E-01 24 0.537E+00 0.158E-01RMM: 2 -0.403117625130E+02 0.18376E-04 -0.29369E-03 24 0.398E-01 0.104E-01RMM: 3 -0.403116565207E+02 0.10599E-03 -0.11484E-03 24 0.208E-01 0.277E-02RMM: 4 -0.403116311378E+02 0.25383E-04 -0.55540E-05 24 0.497E-02 0.164E-02RMM: 5 -0.403116387094E+02 -0.75717E-05 -0.65271E-05 24 0.434E-02 0.890E-03RMM: 6 -0.403116363827E+02 0.23268E-05 -0.17024E-05 24 0.217E-02 0.378E-03RMM: 7 -0.403116417002E+02 -0.53175E-05 -0.29605E-06 19 0.107E-02 0.349E-03RMM: 8 -0.403116414128E+02 0.28742E-06 -0.12248E-06 17 0.640E-03 4 T= 196. E= -.40208892E+02 F= -.40385911E+02 E0= -.40385911E+02 EK= 0.17702E+00 SP= 0.00E+00 SK= 0.00E+00 bond charge predicted prediction of wavefunctions N E dE d eps ncg rms rms(c)RMM: 1 -0.403062082681E+02 0.54334E-02 -0.16770E-02 24 0.119E+00 0.417E-02RMM: 2 -0.403061969844E+02 0.11284E-04 -0.15896E-04 24 0.916E-02 0.270E-02RMM: 3 -0.403061936019E+02 0.33826E-05 -0.10873E-04 24 0.615E-02 0.101E-02RMM: 4 -0.403061899714E+02 0.36305E-05 -0.84127E-06 24 0.170E-02 0.621E-03RMM: 5 -0.403061909422E+02 -0.97076E-06 -0.89813E-06 24 0.161E-02 5 T= 201. E= -.40196935E+02 F= -.40379213E+02 E0= -.40379213E+02 EK= 0.18228E+00 SP= 0.00E+00 SK= 0.00E+00 bond charge predicted prediction of wavefunctions wavefunctions rotated","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"vasp","slug":"vasp","permalink":"http://example.com/tags/vasp/"},{"name":"分子动力学","slug":"分子动力学","permalink":"http://example.com/tags/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/"}]},{"title":"ABACUS编译&测试","slug":"ABACUS编译-测试","date":"2022-02-28T01:04:07.000Z","updated":"2023-08-25T03:13:00.817Z","comments":true,"path":"2022/02/28/ABACUS编译-测试/","link":"","permalink":"http://example.com/2022/02/28/ABACUS%E7%BC%96%E8%AF%91-%E6%B5%8B%E8%AF%95/","excerpt":"安装安装依赖需要载入intel-parallel-studio@cluster.2019.5、intel-mpi以及intel=oneapi-mpi","text":"安装安装依赖需要载入intel-parallel-studio@cluster.2019.5、intel-mpi以及intel=oneapi-mpi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mkdir -p ~/code/intelcd ~/code/intelROOT=$PWDmkdir $ROOT/source###fftw3cd $ROOT/sourcewget https://cndaqiang.gitee.io/packages//mirrors/fftw/fftw-3.3.4.tar.gztar xzvf fftw-3.3.4.tar.gzcd fftw-3.3.4./configure --prefix=$ROOT/fftw-3.3.4 CC=icc MPICC=mpiicc --enable-mpimake install -j20###boostcd $ROOT/sourcewget https://cndaqiang.gitee.io/packages//mirrors/boost/boost_1_66_0.tar.bz2tar --bzip2 -xf boost_1_66_0.tar.bz2cd boost_1_66_0/./bootstrap.sh --prefix=$ROOT/boost_1_66_0 --with-toolset=intel-linux./b2 install -j20###elpaTAG=2016.05.004ROOT=~/code/intelcd $ROOT/sourceif [ ! -f elpa-$TAG.tar.gz ]then wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/$TAG/elpa-$TAG.tar.gzfirm -rf elpa-$TAGrm -rf $ROOT/elpa-$TAGtar xzvf elpa-$TAG.tar.gzcd elpa-$TAGMKL_HOME=$MKLROOTif [ ! -f configure ]then ./autogen.shfirm -rf buildmkdir buildcd build../configure --prefix=$ROOT/elpa-$TAG CC=mpiicc CXX=mpiicpc FC=mpiifort FCFLAGS=&quot;-mkl=cluster&quot;#使用 FCFLAGS=&quot;-mkl=cluster&quot; 或者下面的方式定义SCALAPACK都是可以的# SCALAPACK_LDFLAGS=&quot;-L$MKL_HOME/lib/intel64 -lmkl_scalapack_lp64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lmkl_blacs_intelmpi_lp64 -lpthread -lm -Wl,-rpath,$MKL_HOME/lib/intel64&quot; \\# SCALAPACK_FCFLAGS=&quot;-L$MKL_HOME/lib/intel64 -lmkl_scalapack_lp64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lmkl_blacs_intelmpi_lp64 -lpthread -lm -I$MKL_HOME/include/intel64/lp64&quot; \\#--enable-openmpmake install -j20 #多线程加速编译 安装1234567891011121314151617181920212223242526272829#cd ~/code/abacus/ABACUS_v2.1.0/source/cd $ROOTif [ ! -f ABACUS_v2.1.0.tar.gz ]thenwget https://abacus.ustc.edu.cn/uploadfile/ABACUS_v2.1.0.tar.gzfirm -rf ABACUS_v2.1.0tar xzvf ABACUS_v2.1.0.tar.gzcd ABACUS/sourcecat &gt; Makefile.vars &lt;&lt; EOFCPLUSPLUS = icpc# C++ compilerCPLUSPLUS_MPI = mpiicpc# intel mpi or mpichFORTRAN = ifort# Fortran compiler# 如果报错先检查是否正确导入模块LAPACK_DIR = $MKLROOT# intel mklFFTW_DIR = $ROOT/fftw-3.3.4# lib fftwBOOST_DIR = $ROOT/boost_1_66_0# lib boostELPA_DIR = $ROOT/elpa-$TAG# lib elpaEOFmake 测试运行在ABACUS/example下有几个测试样例,选取第一个测试样例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ mpirun -np 10 ABACUS.mpi.2.1.0 | tee result ********************************************************* * * * WELCOME TO ABACUS * * * * &#x27;Atomic-orbital Based Ab-initio * * Computation at UStc&#x27; * * * * Website: http://abacus.ustc.edu.cn/ * * * ********************************************************* Mon Feb 28 09:37:29 2022 MAKE THE DIR : OUT.ABACUS/ DONE(0.0481156 SEC) : SETUP UNITCELL DONE(0.0736459 SEC) : SYMMETRY DONE(0.0949633 SEC) : INIT K-POINTS --------------------------------------------------------- This calculation is self-consistent --------------------------------------------------------- SPIN KPOINTS PROCESSORS 1 8 10 --------------------------------------------------------- Use plane wave basis --------------------------------------------------------- ELEMENT NATOM XC Si 2 PZ-LDA --------------------------------------------------------- Initial plane wave basis and FFT box --------------------------------------------------------- DONE(0.116594 SEC) : INIT PLANEWAVE UNIFORM GRID DIM : 36 * 36 * 36 UNIFORM GRID DIM(BIG): 36 * 36 * 36 MEMORY FOR PSI (MB) : 0.0820312 DONE(0.120233 SEC) : LOCAL POTENTIAL DONE(0.129086 SEC) : NON-LOCAL POTENTIAL START POTENTIAL : atomic DONE(0.135346 SEC) : INIT POTENTIAL DONE(0.17863 SEC) : INIT BASIS ------------------------------------------- SELF-CONSISTENT : ------------------------------------------- ITER ETOT(eV) EDIFF(eV) DRHO2 CG_ITER TIME(S) CG1 -2.192279e+02 0.000000e+00 6.928e-02 3.000e+00 4.000e-02 CG2 -2.154958e+02 3.732172e+00 5.745e-03 2.750e+00 3.000e-02 CG3 -2.155043e+02 -8.536782e-03 2.622e-05 2.406e+00 2.000e-02 CG4 -2.155047e+02 -3.698259e-04 5.403e-07 3.875e+00 3.000e-02 CG5 -2.155047e+02 -1.855886e-06 1.931e-08 2.875e+00 3.000e-02 CG6 -2.155047e+02 -7.198581e-08 1.776e-10 2.969e+00 2.000e-02 |CLASS_NAME---------|NAME---------------|TIME(Sec)-----|CALLS----|AVG------|PER%------- A DC_Driv solve_eachf 0.24 1 0.24 68 % B Run_Frag frag_pw_line 0.24 1 0.24 68 % X FFT FFT3D 0.13 1876 7.1e-05 37 % H Hamilt_PW h_psi 0.14 828 0.00017 38 % C Ions opt_ions_pw 0.18 1 0.18 50 % D electrons self_consistent 0.18 1 0.18 50 % E electrons c_bands 0.14 6 0.023 38 % F Hamilt diago 0.13 48 0.0028 37 % ---------------------------------------------------------------------------------------- START Time : Mon Feb 28 09:37:29 2022 FINISH Time : Mon Feb 28 09:37:30 2022 TOTAL Time : 1 SEE INFORMATION IN : OUT.ABACUS/ 输入与输出12345678910111213141516171819$ tree.├── INPUT #控制参数├── KPT #k个点├── OUT.ABACUS #输出结果│ ├── INPUT│ ├── istate.info│ ├── running_scf.log│ ├── Si│ │ ├── Si.NONLOCAL│ │ ├── Si-P.ORBITAL│ │ ├── Si-S.ORBITAL│ │ └── v_loc_g.dat│ ├── STRU_READIN_ADJUST.cif│ └── warning.log├── README #说明文档├── result├── Si.pz-vbc.UPF└── STRU #结构","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"ABACUS","slug":"ABACUS","permalink":"http://example.com/tags/ABACUS/"}]},{"title":"gromacs编译&测试","slug":"gromacs编译&测试","date":"2022-02-23T06:12:12.000Z","updated":"2023-08-25T03:13:35.110Z","comments":true,"path":"2022/02/23/gromacs编译&测试/","link":"","permalink":"http://example.com/2022/02/23/gromacs%E7%BC%96%E8%AF%91&%E6%B5%8B%E8%AF%95/","excerpt":"编译gromacs(单精度版本)需要的编译环境为： 串行编译器：Intel Compiler &#x2F; GNU Compiler MPI编译器：mpich &#x2F; openmpi（如果是MPI版本） cmake fftw CUDA（如果是GPU版本） plumed（如果开启plumed）","text":"编译gromacs(单精度版本)需要的编译环境为： 串行编译器：Intel Compiler &#x2F; GNU Compiler MPI编译器：mpich &#x2F; openmpi（如果是MPI版本） cmake fftw CUDA（如果是GPU版本） plumed（如果开启plumed） 123456789101112131415tar -zxvf gromacs-5.1.4.tar.gz # 以5.1.4版本为例cd gromacs-5.1.4 mkdir buildcd buildcmake .. -DCMAKE_INSTALL_PREFIX=$HOME/software/gromacs-5.1.4 \\ -DCMAKE_C_COMPILER=icc -DCMAKE_CXX_COMPILER=icpc \\ -DGMX_DOUBLE=off \\ -DGMX_FFT_LIBRARY=fftw3 \\ -DFFTWF_LIBRARY=&quot;$HOME/fftw/lib/libfftw3f.a&quot; \\ -DFFTWF_INCLUDE_DIR=&quot;$HOME/fftw/include/&quot; \\ -DGMX_MPI=on \\ -DGMX_GPU=off \\ 2&gt;&amp;1 | tee cm.logmake -j12 2&gt;&amp;1 | tee m.logmake install 2&gt;&amp;1 | tee mi.log 参数 含义 -DCMAKE_INSTALL_PREFIX 安装目录 -DCMAKE_C_COMPILER&#x3D;icc 使用 icc 编译 c -DCMAKE_CXX_COMPILER&#x3D;icpc 使用 icpc 编译 cpp -DGMX_DOUBLE&#x3D;off 关闭double，编译单精度版本 -DGMX_FFT_LIBRARY&#x3D;fftw3 使用 fftw3 -DFFTWF_LIBRARY&#x3D;”$HOME&#x2F;fftw&#x2F;lib&#x2F;libfftw3f.a” fftw库,请改为自己的安装目录 -DFFTWF_INCLUDE_DIR&#x3D;”$HOME&#x2F;fftw&#x2F;include” fftw的头文件目录,请改为自己的安装目录 -DGMX_MPI&#x3D;on 开启 MPI 支持 -DGMX_GPU&#x3D;off 关闭 GPU 支持 在安装完成后,运行以下脚本以配置环境: 12$ source $HOME/software/gromacs-5.1.4/bin/GMXRC$ gmx_mpi --version #输出版本信息 gromacs测试样例测试样例为~&#x2F;gromacs. 首先执行以下命令生成可执行.tpr 文件: 1$ gmx_mpi grompp -f md0.mdp -c pr.gro -p SYS.top -o md.tpr grompp参数列表: 参数 含义 -f[&lt;.mdp&gt;] (grompp.mdp) 带有 MD 参数的 grompp 输入文件 -c[&lt;.gro&#x2F;.g96&#x2F;…&gt;] (conf.gro) 结构文件:gro g96 pdb brk ent esp tpr -p[&lt;.top&gt;] (topol.top) 拓扑文件 -o[&lt;.tpr&gt;] (topol.tpr) 便携式 xdr 运行输入文件 -po[&lt;.mdp&gt;] (mdout.mdp) 带有 MD 参数的 grompp 输入文件 然后执行以下命令进行计算: 1$ gmx_mpi mdrun -deffnm md mdrun 参数列表: 参数 含义 -deffnm &lt;字符串&gt; 为所有文件选项设置默认文件名 -s [&lt;.tpr&gt;] (topol.tpr) 便携式 xdr 运行输入文件 -g [&lt;.log&gt;] (md.log) 日志文件 mpicxx&#x2F;mpirunmpicxxmpicxx可用于编译和链接用 C++ 编写的 MPI 程序,在使用前需载入 inteloneapi-mpi hello.c 12345678910111213141516171819202122232425262728#include &lt;mpi.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv) &#123; // 初始化 MPI 环境 MPI_Init(NULL, NULL); // 通过调用以下方法来得到所有可以工作的进程数量 int world_size; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); // 得到当前进程的秩 int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); // 得到当前进程的名字 char processor_name[MPI_MAX_PROCESSOR_NAME]; int name_len; MPI_Get_processor_name(processor_name, &amp;name_len); // 打印一条带有当前进程名字,秩以及 // 整个 communicator 的大小的 hello world 消息。 printf(&quot;Hello world from processor %s, rank %d out of %d processors\\n&quot;, processor_name, world_rank, world_size); // 释放 MPI 的一些资源 MPI_Finalize();&#125; 编译 hello.c 文件 1$ mpicxx -c hello.c 链接 1$ mpicxx -o hello hello.o 组合编译和链接 1$ mpicxx -o hello hello.c mpicxx 参数列表: 参数 含义 -show 在不运行的情况下展示使用的指令 -c [&lt;.c&#x2F;.cxx&#x2F;.cpp&gt;] (hello.c) 编译 -o [&lt;.o&gt;] (hello.o) 链接 mpirunorterun、mpirun、mpiexec 在 Open MPI 中执行串行和并行作业。 oshrun, shmemrun 在 Open SHMEM 中执行串行和并行作业。 mpirun 参数列表: 参数 含义 -q, –quiet 在应用程序执行期间减少来自orterun的信息 -v, –verbose 显示更多信息 -N 在每个分配的node上启动num个进程(与npernode 相同) 在本地直接执行 hello 12$ ./hello Hello world from processor master1, rank 0 out of 1 processors 使用 mpirun 执行 hello 12345$ mpirun -n 4 ./hello Hello world from processor master1, rank 1 out of 4 processors Hello world from processor master1, rank 3 out of 4 processors Hello world from processor master1, rank 0 out of 4 processors Hello world from processor master1, rank 2 out of 4 processors slurmSlurm(Simple Linux Utility for Resource Management，http://slurm.schedmd.com/) 是开源的、具有容错性和高度可扩展大型和小型 Linux 集群资源管 理和作业调度系统。超级计算系统可利用 Slurm 进行资源和作业管理，以避免 相互干扰，提高运行效率。 三种基本模式批处理作业(采用 sbatch 命令提交，最常用方式) 使用 sbatch 命令提交作业脚本 提交后立即返回该命令行终端，用户可进行其它操作 在作业脚本中也可使用 srun 命令加载作业任务 交互式作业提交(采用 srun 命令提交) 资源分配与任务加载两步均通过 srun 命令进行 用户在该终端需等待任务结束才能继续其它操作 如果提交时的命令行终端断开，则任务终止 实时分配模式作业(采用 salloc 命令提交) 分配作业模式类似于交互式作业模式和批处理作业模式的融合 请求资源-&gt;队列等待-&gt;在提交节点执行指定命令-&gt;资源释放 在作业结束前，如果提交时的命令行终端断开，则任务终止。 提交作业 使用 srun 命令提交作业12345$ srun -n 4 ./hello Hello world from processor node1, rank 3 out of 4 processors Hello world from processor node1, rank 0 out of 4 processors Hello world from processor node1, rank 1 out of 4 processors Hello world from processor node1, rank 2 out of 4 processors 使用 sbatch 命令提交作业12345678910$ cat myscript.sh #!/bin/sh#SBATCH --nodes=1#SBATCH --ntasks-per-node=1 #SBATCH -o job.hello%j.out srun -n 1 ./hello$ sbatch myscript.sh Submitted batch job 375 $ cat job.hello375.out Hello world from processor node1, rank 0 out of 1 processors","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"gromacs","slug":"gromacs","permalink":"http://example.com/tags/gromacs/"}]},{"title":"spack配置与使用","slug":"spack配置与使用","date":"2022-02-21T08:42:47.000Z","updated":"2023-08-25T03:25:25.791Z","comments":true,"path":"2022/02/21/spack配置与使用/","link":"","permalink":"http://example.com/2022/02/21/spack%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"安装spack123git clone -c feature.manyFiles=true https://github.com/spack/spack.gitcd spack/bin./spack install zlib","text":"安装spack123git clone -c feature.manyFiles=true https://github.com/spack/spack.gitcd spack/bin./spack install zlib 常用命令常用命令如下： 命令 功能 例子 spack list 列出可用spack安装的全部软件 spack info 查询可安装软件的基本信息 spack info vasp spack find 查询已安装的软件 spack find gcc spack load 加载已安装软件的环境变量 spack load cmake spack unload 卸载加载的软件的环境变量 spack unload cmake spack install 安装软件 spack install gromacs 加载spack包管理器环境变量1source spack/share/spack/setup-env.sh 将编译器加入spack编译器配置执行spack compiler find可以将当前环境变量的编译器加载到spack编译器配置中,默认的配置文件在 $HOME/.spack/linux/compilers.yaml 123spack find gccspack load gcc@8.5.0spack compiler find 纳入已安装的软件到spack执行spack exteranl find可以将当前环境变量中包含bin目录的软件纳入spack管理，默认的配 置文件在$HOME/.spack/packages.yaml 添加软件源码镜像仓库执行spack mirror add &lt;name&gt; &lt;path&gt;,例如添加软件源码镜像仓库spack mirror add local /es01/jnist/mirror,我们默认添加了这个镜像仓库 其他基础配置通过spack config get config &gt; config.yaml生成一份spack基础配置到$HOME/.spack下 命令详解查询可安装软件执行spack list可以查询可由spack安装的全部软件.有的时候,所需的软件的名字可能在spack软件列表不同,比如数学库blas、lapack、scalapack的实现会有好多种,下面我们展示下所有lapack的实现, 只需要在list后加-d参数 1spack list -d lapack 查询可安装软件的基本信息执行spack info &lt;package&gt;可以查询可安装软件的基本信息.例如,查询vasp的基本信息:spack info vasp这样会打印出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051spack info vaspMakefilePackage: vaspDescription: The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.Homepage: https://vasp.atExternally Detectable: FalseTags: NonePreferred version: 6.1.1 file:///es01/yeesuan/yeesuan003/vasp.6.1.1.tgzSafe versions: 6.1.1 file:///es01/yeesuan/yeesuan003/vasp.6.1.1.tgz 5.4.4.pl2 file:///es01/yeesuan/yeesuan003/vasp.5.4.4.pl2.tgz 5.4.4 file:///es01/yeesuan/yeesuan003/vasp.5.4.4.tgzDeprecated versions: NoneVariants: Name [Default] When Allowed values Description =============== ==== ============== ============================================================= cuda [off] -- on, off Enables running on Nvidia GPUs scalapack [off] -- on, off Enables build with SCALAPACK vaspsol [off] -- on, off Enable VASPsol implicit solvation model https://github.com/henniggroup/VASPsolInstallation Phases: edit build installBuild Dependencies: blas cuda fftw lapack mpi netlib-scalapack qd rsyncLink Dependencies: blas cuda fftw lapack mpi netlib-scalapack qdRun Dependencies: mpiVirtual Packages: None 查询已安装软件执行spack find可以查询使用spack安装好的全部软件 在find后加入-d(取依赖的英语单词dependencies的首字母)参数可以查看软件使用的依赖,例 如查看vasp6.1.0使用的依赖 12345678[yeesuan003@spack ~]$ spack find -d vasp@6.1.0==&gt; 1 installed package-- linux-centos7-cascadelake / intel@19.0.5.281 -----------------vasp@6.1.0 fftw@3.3.10 intel-mpi@2019.5.281 intel-mkl@2019.5.281 netlib-scalapack@2.1.0 环境变量加载软件的环境变量1spack load &lt;package&gt; 有时候我们需要加载多个软件的环境变量，我们可以使用spack load &lt;package1&gt; &lt;package2&gt; ...例如加载intel2019和gcc6.5.0 1spack load intel-parallel-studio@cluster.2019.5 gcc@6.5.0 使用hash值加载软件的环境变量有时候我们想加载某个软件，但它存在多个同名的软件时直接加载会报错,可以使用spack load /&lt;hash&gt; 123456789spack load gcc==&gt; Error: gcc matches multiple packages. Matching packages: io5n6ud gcc@6.5.0%gcc@4.8.5 arch=linux-centos7-haswell x4guukb gcc@7.5.0%gcc@4.8.5 arch=linux-centos7-haswell k63wbs4 gcc@8.5.0%gcc@4.8.5 arch=linux-centos7-haswell 6icy7ve gcc@10.2.0%gcc@4.8.5 arch=linux-centos7-haswell Use a more specific spec.spack load /k63wbs4 查看加载的环境变量1spack load --sh &lt;package&gt; 获取软件安装位置和可执行文件名字1spack location -i &lt;package&gt; 当然也可以使用hash值获取, 1spack location -i /&lt;hash&gt; 安装软件1spack install &lt;package&gt; 通常,我们需要指定编译软件所需要的编译器,使用spack compilers可以查看spack可以使用的编译器","categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]},{"title":"Matlab实验3-1","slug":"Matlab实验3-1","date":"2021-04-22T09:39:00.000Z","updated":"2023-08-25T03:26:38.649Z","comments":true,"path":"2021/04/22/Matlab实验3-1/","link":"","permalink":"http://example.com/2021/04/22/Matlab%E5%AE%9E%E9%AA%8C3-1/","excerpt":"矩阵特征多项式、特征值、特征向量，稀疏矩阵 测试函数poly, poly2str, eig","text":"矩阵特征多项式、特征值、特征向量，稀疏矩阵 测试函数poly, poly2str, eig 123456789clc;clear;format short gA = [1, 2, 3; 4, 5, 6; 7, 8, 9];p = poly(A)poly2str(p, &#x27;x&#x27;)d = eig(A)[V, D] = eig(A)A * V - V * D 测试函数sparse, spdiags 123A = [0, 0, 5, 0; 3, 0, 3, 0; 0, 0, 0, 1; 0, 4, 3, 0]S1 = sparse(A)full(S1) 专题实验（迭代法求解线性方程组） 编写Jacobi迭代格式解线性方程组的函数； 编写Gauss-Seidel迭代格式求解线性方程组的函数； 建议用矩阵形式编写，也可以用原始格式。 对下面四个例题进行实验 (1){10x1−x2−2x3=7.2−x1+10x2−2x3=8.3−x1−x2+5x3=4.2\\left\\{ \\begin{aligned} &amp; 10x_1-x_2-2x_3=7.2\\\\ &amp; -x_1+10x_2-2x_3=8.3\\\\ &amp; -x_1-x_2+5x_3=4.2\\\\ \\end{aligned} \\right.⎩⎪⎪⎨⎪⎪⎧​​10x1​−x2​−2x3​=7.2−x1​+10x2​−2x3​=8.3−x1​−x2​+5x3​=4.2​ (2){10x1−x2−2x3=7.2−x1+10x2−2x3=8.3−x1−x2+0.5x3=4.2\\left\\{ \\begin{aligned} &amp; 10x_1-x_2-2x_3=7.2\\\\ &amp; -x_1+10x_2-2x_3=8.3\\\\ &amp; -x_1-x_2+0.5x_3=4.2\\\\ \\end{aligned} \\right.⎩⎪⎪⎨⎪⎪⎧​​10x1​−x2​−2x3​=7.2−x1​+10x2​−2x3​=8.3−x1​−x2​+0.5x3​=4.2​ (3){x1−9x2−10x3=1−9x1+x2+5x3=08x1+7x2+x3=4\\left\\{ \\begin{aligned} &amp; x_1-9x_2-10x_3=1\\\\ &amp; -9x_1+x_2+5x_3=0\\\\ &amp; 8x_1+7x_2+x_3=4\\\\ \\end{aligned} \\right.⎩⎪⎪⎨⎪⎪⎧​​x1​−9x2​−10x3​=1−9x1​+x2​+5x3​=08x1​+7x2​+x3​=4​ (4){5x1−x2−3x3=−1−x1+2x2+4x3=0−3x1+4x2+15x3=4\\left\\{ \\begin{aligned} &amp; 5x_1-x_2-3x_3=-1\\\\ &amp; -x_1+2x_2+4x_3=0\\\\ &amp; -3x_1+4x_2+15x_3=4\\\\ \\end{aligned} \\right.⎩⎪⎪⎨⎪⎪⎧​​5x1​−x2​−3x3​=−1−x1​+2x2​+4x3​=0−3x1​+4x2​+15x3​=4​ Jacobi源代码TestJacobi.m 12345678910111213141516A1 = [10, -1, -2; -1, 10, -2; -1, -1, 5];b1 = [7.2; 8.3; 4.2];ans1 = myJacobi(A1, b1)A2 = [10, -1, -2; -1, 10, -2; -1, -1, 0.5];b2 = [7.2; 8.3; 4.2];ans2 = myJacobi(A2, b2)A3 = [1, -9, -10; -9, 1, 5; 8, 7, 1];b3 = [1; 0; 4];ans3 = myJacobi(A3, b3)A4 = [5, -1, -3; -1, 2, 4; -3, 4, 15];b4 = [-1; 0; 4];ans4 = myJacobi(A4, b4) myJacobi.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function x = myJacobi(A, b, X0, mytol) % A为系数矩阵. % b为右端常向量. % X0为初始层，默认取0. % mytol表示允许误差, 要求默认值为1e-6. % 判断参数 if nargin == 3 mytol = 1.0e-6; elseif nargin == 2 mytol = 1.0e-6; N = length(b); %解向量的维数 X0 = zeros(N, 1); %迭代初始值 elseif nargin &lt; 2 error(&#x27;输入参数不足&#x27;); return end % 判断系数矩阵是否是方阵 [A_row, A_col] = size(A); [b_row, b_col] = size(b); if A_row ~= A_col error(&#x27;系数矩阵不是方阵&#x27;); x = zeros(A_row, 1); return end % 判断b是否为常向量 if b_col ~= 1 disp(&#x27;b不是常向量&#x27;); x = zeros(A_row, 1); return; end % 判断常向量是否匹配 if A_row ~= b_row disp(&#x27;系数矩阵与常向量不匹配&#x27;); x = zeros(A_row, 1); return; end % 判断系数矩阵是否可逆 if abs(det(A)) &lt; mytol disp(&#x27;系数矩阵不可逆&#x27;); x = zeros(A_row, 1); return end D = diag(diag(A)); % 求A的对角矩阵 L = -tril(A, -1); % 求A的下三角矩阵 U = -triu(A, 1); % 求A的上三角矩阵 B = D \\ (L + U); % Jacobi迭代矩阵 e = abs(eig(B)); % 求特征值，判断是否收敛 if e &gt; 1 disp(&#x27;不收敛&#x27;) x = zeros(A_row, 1); return; end f = D \\ b; x = B .* X0 + f; n = 1; % 迭代次数 while norm(x - X0) &gt;= mytol % 进行迭代 X0 = x; x = B * X0 + f; n = n + 1; end x = x(:, 1);end 运行结果1234567891011121314151617181920212223242526272829&gt;&gt; TestJacobians1 = 1.1000 1.2000 1.3000ans2 = 24.5000 24.6000 106.6000不收敛ans3 = 0 0 0ans4 = -0.0984 -1.1639 0.5574 Gauss-Seidel源代码TestGS.m 12345678910111213141516A1 = [10, -1, -2; -1, 10, -2; -1, -1, 5];b1 = [7.2; 8.3; 4.2];ans1 = myGS(A1, b1)A2 = [10, -1, -2; -1, 10, -2; -1, -1, 0.5];b2 = [7.2; 8.3; 4.2];ans2 = myGS(A2, b2)A3 = [1, -9, -10; -9, 1, 5; 8, 7, 1];b3 = [1; 0; 4];ans3 = myGS(A3, b3)A4 = [5, -1, -3; -1, 2, 4; -3, 4, 15];b4 = [-1; 0; 4];ans4 = myGS(A4, b4) myGS.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function x = myGS(A, b, X0, mytol) % A为系数矩阵. % b为右端常向量. % X0为初始层，默认取0. % mytol表示允许误差, 要求默认值为1e-6. % A为系数矩阵. % b为右端常向量. % X0为初始层，默认取0. % mytol表示允许误差, 要求默认值为1e-6. % 判断参数 if nargin == 3 mytol = 1.0e-6; elseif nargin == 2 mytol = 1.0e-6; N = length(b); % 解向量的维数 X0 = zeros(N, 1); % 迭代初始值 elseif nargin &lt; 2 error(&#x27;输入参数不足&#x27;); return end % 判断系数矩阵是否是方阵 [A_row, A_col] = size(A); [b_row, b_col] = size(b); if A_row ~= A_col error(&#x27;系数矩阵不是方阵&#x27;); x = zeros(A_row, 1); return end % 判断b是否为常向量 if b_col ~= 1 disp(&#x27;b不是常向量&#x27;); x = zeros(A_row, 1); return; end % 判断常向量是否匹配 if A_row ~= b_row disp(&#x27;系数矩阵与常向量不匹配&#x27;); x = zeros(A_row, 1); return; end % 判断系数矩阵是否可逆 if abs(det(A)) &lt; mytol disp(&#x27;系数矩阵不可逆&#x27;); x = zeros(A_row, 1); return end %将矩阵分裂为A=D-L-U D = diag(diag(A)); L = -tril(A, -1); %下三角 U = -triu(A, 1); %上三角 g = (D - L) \\ b; B = (D - L) \\ U; % TODO:判断收敛 x = B * X0 + g; while norm(x - X0) &gt;= mytol X0 = x; x = B * X0 + g; endend 运行结果12345678910111213141516171819202122232425262728&gt;&gt; TestGSans1 = 1.1000 1.2000 1.3000ans2 = 24.5000 24.6000 106.6000ans3 = -Inf -Inf Infans4 = -0.0984 -1.1639 0.5574","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Java矩形类","slug":"Java矩形类","date":"2021-04-22T09:23:06.000Z","updated":"2023-08-25T03:26:59.307Z","comments":true,"path":"2021/04/22/Java矩形类/","link":"","permalink":"http://example.com/2021/04/22/Java%E7%9F%A9%E5%BD%A2%E7%B1%BB/","excerpt":"项目结构1234567$ tree -C -L 3.└── top └── lhxone ├── Main.java └── myRect","text":"项目结构1234567$ tree -C -L 3.└── top └── lhxone ├── Main.java └── myRect 代码Main.java 12345678910111213141516package top.lhxone;import top.lhxone.myRect.PlainRect;public class Main &#123; public static void main(String[] args) &#123; PlainRect r=new PlainRect(10,10,10,20); System.out.println(&quot;面积为&quot;+r.area()); if (r.isInside(25.5,13))&#123; System.out.println(&quot;在矩形内.&quot;); &#125;else &#123; System.out.println(&quot;不在矩形内.&quot;); &#125; &#125;&#125; Rect.java 123456789101112131415161718192021222324package top.lhxone.myRect;public class Rect &#123; protected double width, height; Rect(double width, double height) &#123; this.width = width; this.height = height; &#125; public Rect() &#123; this.width = 1.0; this.height = 1.0; &#125; public double area() &#123; return this.height * this.width; &#125; public double perimeter()&#123; return 2*(this.width+this.height); &#125;&#125; PlainRect.java 123456789101112131415161718192021222324252627package top.lhxone.myRect;public class PlainRect extends Rect &#123; double startX, startY; PlainRect() &#123; this.startX = 1.0; this.startY = 1.0; super.height = 1.0; super.width = 1.0; &#125; public PlainRect(double X, double Y, double width, double height) &#123; this.startX = X; this.startY = Y; super.width = width; super.height = height; &#125; public boolean isInside(double x, double y) &#123; if (x &lt; startX + width &amp;&amp; x &gt; startX &amp;&amp; y &lt; startY &amp;&amp; y &gt; startY - height) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"C++学生成绩","slug":"C-学生成绩","date":"2021-04-13T15:23:43.000Z","updated":"2023-08-25T02:16:39.239Z","comments":true,"path":"2021/04/13/C-学生成绩/","link":"","permalink":"http://example.com/2021/04/13/C-%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9/","excerpt":"代码","text":"代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;math.h&gt;void func1(double stu[10][6]) &#123; //计算各科平均分 for (int i = 0; i &lt; 10; ++i) &#123; if (!i) &#123; printf(&quot;编号\\ts1\\t\\ts2\\t\\ts3\\t\\ts4\\t\\ts5\\t\\t平均成绩\\n&quot;); &#125; printf(&quot;%d\\t&quot;, i + 1); for (int j = 0; j &lt; 6; ++j) &#123; printf(&quot;%.2lf\\t&quot;, stu[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125;void func2(double stu[10][6]) &#123; //各科平均成绩 double class_sum[5] = &#123;0&#125;; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 5; ++j) &#123; class_sum[j] += stu[i][j]; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; class_sum[i] /= 10; &#125; printf(&quot;平均\\t&quot;); for (int i = 0; i &lt; 5; ++i) &#123; printf(&quot;%.2lf\\t&quot;, class_sum[i]); &#125; printf(&quot;\\n&quot;);&#125;void func3(double stu[10][6]) &#123; //最高分 double max_num = -1; int max_row, max_col; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 5; ++j) &#123; if (stu[i][j] &gt; max_num) &#123; max_num = stu[i][j]; max_row = i; max_col = j; &#125; &#125; &#125; printf(&quot;最高分数为：%.2lf,科目为：s%d,学生编号为：%d\\n&quot;, max_num, max_col + 1, max_row + 1);&#125;void func4(double stu[10][6]) &#123; //方差 double Dx, Sigma1 = 0, Sigma2 = 0; for (int i = 0; i &lt; 10; ++i) &#123; Sigma1 += stu[i][5]; Sigma2 += pow(stu[i][5], 2); &#125; Dx = (Sigma2 / 10) - (pow(Sigma1 / 10, 2)); printf(&quot;平均分方差为：%.2lf\\n&quot;, Dx);&#125;int main() &#123; double stu[10][6] = &#123;0&#125;; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 5; ++j) &#123; stu[i][j] = (random() % 40) + 50;// scanf(&quot;%lf&quot;, &amp;stu[i][j]); stu[i][5] += stu[i][j]; &#125; stu[i][5] = stu[i][5] / 5; //计算每个学生平均分 &#125; func1(stu); func2(stu); func3(stu); func4(stu);&#125;","categories":[],"tags":[]},{"title":"C语言extern与static","slug":"C语言extern与static","date":"2021-04-13T10:04:38.000Z","updated":"2023-08-25T03:13:26.780Z","comments":true,"path":"2021/04/13/C语言extern与static/","link":"","permalink":"http://example.com/2021/04/13/C%E8%AF%AD%E8%A8%80extern%E4%B8%8Estatic/","excerpt":"static示例","text":"static示例 123456789101112131415#include &lt;iostream&gt;using namespace std;void out() &#123; static int n = 0; n++; cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl;&#125;int main() &#123; out(); //第一次调用out() out(); //第二次调用out() out(); //第三次调用out()&#125; 运行结果12345n=1n=2n=3Process finished with exit code 0 解释第一次out()被调用，申请一个空间用来存放n，执行一次初始化。第一次调用结束后，存储空间并未被释放，即生命周期延长了。第二&#x2F;三次调用，不再申请新的存储空间，而是继续使用第一次的存储空间，但是不执行n = 0;的赋值，n的值仍然为原来的值。 extern 注：定义要为变量分配内存空间；而声明不需要为变量分配内存空间。extern是声明，而非定义，即通知编译器，此处只是该变量（或函数，但是函数一般不使用extern）的声明，不会分配内存，而真正的定义在别处。 定义时，extern可以省略。定义时，extern可以省略。定义时，extern可以省略。示例extern一般用于自定义的*.h文件中 12345extern int a; // 声明一个全局变量 aint a; // 定义一个全局变量 aextern int a =0 ; // 定义一个全局变量 a 并给初值。int a =0; // 定义一个全局变量 a, 并给初值，//第三和第四是一样的 123456789//demo.cpp#include &lt;iostream&gt;#include &quot;demo.h&quot;using namespace std;int main() &#123; cout&lt;&lt;b;&#125; 12345//demo.hextern int a;int b = 1;extern int c = 2;int d = 3; 输出a时，编译报错；输出b,c,d时，可以正常输出，但提示c被声名为extern,即此处为 1[Warning] &#x27;c&#x27; initialized and declared &#x27;extern&#x27; 解释声明：仅仅表示有一个叫张三的人，他是个医生，他在哪不知道，咱们找不到他 定义：在地球上给一个叫张三的医生分配了地理资源，让他在这一片地理区域内活动，这样就可以知道他在哪，咱们也可以找到他 假如我们有两个文件A和B，在A里，我们完成了对张三的定义，如果我们在B中想再请A中定义的张三为我们工作，那我们就加个extern。extern 张三;这样，程序就知道这个张三的定义在别的文件里，然后程序找到A文件，发现张三的定义，我们就可以找到张三，请他出山来为我们工作了","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"操作系统第二章作业","slug":"操作系统第二章作业","date":"2021-04-13T02:20:32.000Z","updated":"2023-08-25T03:25:03.310Z","comments":true,"path":"2021/04/13/操作系统第二章作业/","link":"","permalink":"http://example.com/2021/04/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"第二章作业 版权声明 版权声明：本文为AYXYJ原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：链接地址 版权声明：本文为qq_33583069原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：链接地址 正文 利用信号量机制来解决任意前驱图所描述的并发执行的过程。（前趋图可自行设计）","text":"第二章作业 版权声明 版权声明：本文为AYXYJ原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：链接地址 版权声明：本文为qq_33583069原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。本文链接：链接地址 正文 利用信号量机制来解决任意前驱图所描述的并发执行的过程。（前趋图可自行设计） 1234567891011var a,b,c,d,e,f,g:semaphore:=0,0,0,0,0,0,0;beginCobeginbegin S1;signal(a);signal(b);end;begin wait(a);s2; signal(c); signal(d); end;begin wait(b);s3; signal(e); end;begin wait(c);s4; signal(f); end;begin wait(d);s5; signal(g); end;begin wait(e);wait(f);wait(g);s6; end;Coendend 图书馆阅览室问题 问题描述：假定阅览室最多可同时容纳100个人阅读，读者进入时，必须在阅览室门口的一个登记表上登记，内容包括姓名. 座号等，离开时要撤掉登记内容。用P、 V操作描述读者进程的同步算法。 123456789101112131415var mutex,res:semaphore;mutex:=1; res:=100;Procedure reader(readerID);&#123; P(res); P(mutex); registrationInformation(readerID); V(mutex); reading(); P(mutex); cancelRecord(readerID); V(mutex); V(res);&#125; 吃水果问题 问题描述：桌上有一只盘子，每次只能放一个水果，爸爸专向盘中放苹果，妈妈专向盘中放桔子，儿子专等吃盘里的桔子，女儿专等吃盘里的苹果。只要盘子空，则爸爸或妈妈可向盘中放水果，仅当盘中有自己需要的水果时，儿子或女儿可从中取出，请给出四人之间的同步关系，并用PV操作实现四人正确活动的程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var mutex,empty,orange,apple:Semaphore;mutex = 1; empty = 1; orange = 0; apple = 0;Cobegin&#123; father //父亲进程 &#123; while (true) &#123; P(empty); P(mutex); 向盘中放苹果; V(mutex); V(apple); &#125; &#125; mother //母亲进程 &#123; while (true) &#123; P(empty); P(mutex); 向盘中放桔子; V(mutex); V(orange); &#125; &#125; daughter //女儿进程 &#123; while (true) &#123; P(apple); P(mutex); 取盘中苹果; V(mutex); V(empty); &#125; &#125; son //儿子进程 &#123; while (true) &#123; P(orange); P(mutex); 取盘中桔子; V(mutex); V(empty); &#125; &#125;&#125;Coend 理发师问题(Dijkstra 1965) 问题描述：一个理发店由一个有几张椅子的等候室和一个放有一张理发椅的理发室组成。若没有要理发的顾客，则理发师就去睡觉；若一顾客走进理发店且所有的椅子都被占用了，则该顾客就离开理发店；若理发师正在为人理发，则该顾客就找一张空椅子坐下等待；若理发师在睡觉，则顾客就唤醒他，设计一个协调理发师和顾客的程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var mutex,Wait,barbers:Semaphore;var custNum:Int;mutex = 1; Wait = 0; babers = 0;custNum = 0;Costumer()&#123; while(true) &#123; P(mutex); if(custNum&gt;0) &#123; if(custNum&lt;N) &#123; V(mutex); CustNum++； &#125; else &#123; V(mutex); 离开; &#125; &#125; else &#123; V(mutex); V(barbers); 理发; 离开; P(mutex); custNum--; V(mutex); V(wait); &#125; &#125;&#125;Barber()&#123; while(true) &#123; P(mutex); if(custNum ==0) &#123; V(mutex); P(barbers); &#125; else &#123; V(mutex); 理发; &#125; &#125;&#125; 司机—售票员问题 设公共汽车上，司机和售票员的活动分别是： 司机 售票员 启动车辆 上下乘客 正常行驶 关车门 到站停车 售票 开车门 上下乘客 在汽车不断到站，停车，行驶过程中，请描述这两个活动的同步关系。（售票员通过关车门控制司机启动车辆；司机通过到站停车控制售票员开车门）。 12345678910111213141516171819202122232425var door,stop:Semaphore;door = 0; stop = 0;void conductor()&#123; while(true) &#123; 上下乘客; 关车门; signal(door); 售票; wait(stop); 开车门; 上下乘客; &#125;&#125;void driver()&#123; while(true) &#123; wait(door); 正常行驶; signal(stop); &#125;&#125; 对哲学进餐问题给出两种（第1、 3）解决死锁方法的程序描述。 方案一 至多允许有四位哲学家同时去拿左边的筷子，然后在允许拿右边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能同时释放他用过的两只筷子，从而使更多的哲学家能够进餐 方案二 仅当哲学家的左，右两只筷子均可用时，才允许他拿起筷子进餐 方案三 规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐 用P、V操作来实现receive 原语:( 参见教材 p80-81) 1234567891011121314151617181920//R:接收进程名,b:欲接收信息所在内存地址//s-b=n; s-m=0; b-mutex=1; m-mutex=1;Receive(R,b)CobeginBegin 根据R找发送进程; 如果没有找到 return error; 申请空缓冲区P(s-b); p(b-mutex); 清空缓冲区; 把消息从b处复制到空缓冲区; V(b-mutex); P(m-mutex); Receive程序查找其消息缓冲区，将第一个消息缓冲区中内容，消息，正文，长度，发送到接收区b; V(m-mutex); V(s-m);EndCoend","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Java银行系统","slug":"Java银行系统","date":"2021-04-10T04:25:15.000Z","updated":"2023-08-25T02:16:39.242Z","comments":true,"path":"2021/04/10/Java银行系统/","link":"","permalink":"http://example.com/2021/04/10/Java%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F/","excerpt":"Java银行系统实现的功能 继承抽象类people，创建customer类 使用构造函数对信息初始化 重载customer的toString方法 实现存款、取款、注册新卡和删除卡片等操作","text":"Java银行系统实现的功能 继承抽象类people，创建customer类 使用构造函数对信息初始化 重载customer的toString方法 实现存款、取款、注册新卡和删除卡片等操作 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130abstract class people &#123; protected String name; protected String gender; protected String uid; protected int age; people(String name, String gender, int age, String uid) &#123; this.name = name; this.gender = gender; this.age = age; this.uid = uid; &#125;&#125;class customer extends people &#123; protected String[] CardID = new String[3]; protected String[] password = new String[3]; protected double[] remain = new double[3]; protected int CardNum = 0; customer(String name, String gender, int age, String uid) &#123; super(name, gender, age, uid); &#125; //TODO:USER Operation @Override public String toString() &#123; return &quot;客户名字为：&quot; + super.name + &quot;，身份证为：&quot; + super.uid + &quot;，卡片数量为：&quot; + this.CardNum; &#125; void showUSERinfo() &#123; System.out.printf(&quot;客户名字为：%s，性别为：%s，身份证为：%s，卡片数量为：%d\\n&quot;, super.name, super.gender, super.uid, this.CardNum); if (CardNum != 0) &#123; System.out.println(&quot;--编号--CardID--Password------------Remain&quot;); for (int i = 0; i &lt; CardNum; i++) &#123; System.out.println(&quot;\\t&quot; + i + &quot;\\t&quot; + CardID[i] + &quot;\\t&quot; + password[i] + &quot;\\t\\t&quot; + remain[i]); &#125; &#125; &#125; //TODO:Card Operation void NewCard(String ID, String password, int remain) &#123; if (this.CardNum &lt; 3) &#123; this.CardID[CardNum] = ID; this.password[CardNum] = password; this.remain[CardNum] = remain; System.out.printf(&quot;卡片创建成功！\\n卡号为：%s，密码为%s。\\n&quot;, this.CardID[CardNum], this.password[CardNum]); CardNum++; &#125; else &#123; System.out.println(&quot;卡片数量已满，无法申请新卡片！&quot;); &#125; &#125; void DelCard(String ID, String password) &#123; if (CardNum == 0) &#123; System.out.println(&quot;没有可用的卡！&quot;); &#125; else &#123; for (int i = 0; i &lt; CardNum; i++) &#123; if (CardID[i] == ID) &#123; if (this.password[i] == password) &#123; for (int j = i; j &lt; CardNum - 1; j++) &#123; CardID[j] = CardID[j + 1]; this.password[j] = this.password[j + 1]; remain[j] = remain[j + 1]; &#125; CardNum--; System.out.println(&quot;卡片删除成功！&quot;); &#125; else &#123; System.out.println(&quot;密码不正确！&quot;); &#125; return; &#125; &#125; &#125; &#125; void getMoney(String ID, String password, double moneyNum) &#123; for (int i = 0; i &lt; CardNum; i++) &#123; if (CardID[i] == ID) &#123; if (this.password[i] == password) &#123; if (moneyNum &lt;= remain[i]) &#123; remain[i] -= moneyNum; System.out.println(&quot;取款成功！已在&quot; + CardID[i] + &quot;取出&quot; + moneyNum + &quot;，账户还剩：&quot; + remain[i]); &#125; &#125; else &#123; System.out.println(&quot;密码不正确！&quot;); &#125; return; &#125; &#125; System.out.println(&quot;未找到此卡片，请检查输入的卡号！&quot;); &#125; void saveMoney(String ID, int moneyNum) &#123; if (moneyNum &lt;= 0) &#123; System.out.println(&quot;无效操作！&quot;); return; &#125; for (int i = 0; i &lt; CardNum; i++) &#123; if (CardID[i] == ID) &#123; remain[i] += moneyNum; System.out.println(&quot;存款成功！已在&quot; + CardID[i] + &quot;存入&quot; + moneyNum + &quot;，账户还剩：&quot; + remain[i]); return; &#125; &#125; System.out.println(&quot;未找到此卡片，请检查输入的卡号！&quot;); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; customer cust; cust = new customer(&quot;张三&quot;, &quot;男&quot;, 23, &quot;12134&quot;); cust.NewCard(&quot;0001&quot;, &quot;thisisapassword&quot;, 1000); cust.NewCard(&quot;0002&quot;, &quot;anotherpassword&quot;, 1200); cust.NewCard(&quot;0003&quot;, &quot;isthirdpassword&quot;, 4200); cust.NewCard(&quot;0004&quot;, &quot;isatestpassword&quot;, 3600);// System.out.println(cust.toString()); cust.showUSERinfo(); cust.getMoney(&quot;0001&quot;, &quot;thisisapassword&quot;, 300); cust.showUSERinfo(); cust.DelCard(&quot;0002&quot;, &quot;anotherpassword&quot;); cust.showUSERinfo(); cust.saveMoney(&quot;0001&quot;, 200); cust.showUSERinfo(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Matlab实验2-3","slug":"Matlab实验2-3","date":"2021-04-06T05:47:09.000Z","updated":"2023-08-25T03:26:32.759Z","comments":true,"path":"2021/04/06/Matlab实验2-3/","link":"","permalink":"http://example.com/2021/04/06/Matlab%E5%AE%9E%E9%AA%8C2-3/","excerpt":"专题实验（分段函数的图像） 请画出以下分段函数在[-10,40]上的图像，每个分段用不同的颜色、线型来描述.","text":"专题实验（分段函数的图像） 请画出以下分段函数在[-10,40]上的图像，每个分段用不同的颜色、线型来描述. f(x)={x,x&lt;1,2x−1,1≤x≤10,3x−11,10&lt;x≤30,sinx+lnx,x&gt;30.f(x)= \\left \\{ \\begin{aligned} &amp; x,&amp; &amp; x&lt;1, \\\\ &amp; 2x-1,&amp; &amp; 1 \\le x \\le 10, \\\\ &amp; 3x-11,&amp; &amp; 10 &lt; x \\le 30,\\\\ &amp; sinx+lnx,&amp; &amp; x &gt; 30. \\end{aligned} \\right.f(x)=⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​​x,2x−1,3x−11,sinx+lnx,​​x&lt;1,1≤x≤10,10&lt;x≤30,x&gt;30.​ 123456789101112131415161718192021222324x = -10:0.1:40;x1 = x(1:110);x2 = x(111:201);x3 = x(202:401);x4 = x(402:501);for index = 1:numel(x1) y1(index) = x1(index);endfor index = 1:numel(x2) y2(index) = 2 * x2(index) - 1;endfor index = 1:numel(x3) y3(index) = 3 * x3(index) - 11;endfor index = 1:numel(x4) y4(index) = sin(x4(index)) + log(x4(index));endplot(x1, y1, &#x27;r*&#x27;, x2, y2, &#x27;bd&#x27;, x3, y3, &#x27;gH&#x27;, x4, y4, &#x27;y^&#x27;) 运行结果 选做题：针对1中的函数f编写函数文件，使得可以直接对矩阵或者数组进行运算，进而快速实现画图. TestFunc.m 1234567891011function y = TestFunc(x) if x&lt;1 y=x; elseif x&lt;=10 y=2*x-1; elseif x&lt;=30 y=3*x-11; else y=sin(x)+log(x); endend 专题实验（二维极坐标画图）从第2次实验附件中至少挑选2个图像进行绘图。 Archimedes螺线r=aθr = a\\thetar=aθ 1234theta = 0:pi / 10:4 * pi;a = 3;r = a * theta;polar(theta, r) 运行结果 双曲螺线rθ=ar\\theta = arθ=a 1234theta = 0:pi / 10:4 * pi;a = 3;r = a ./ theta;polar(theta, r) 运行结果 E N D","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Matlab实验2-2","slug":"Matlab实验2-2","date":"2021-04-05T01:55:07.000Z","updated":"2023-08-25T02:16:39.244Z","comments":true,"path":"2021/04/05/Matlab实验2-2/","link":"","permalink":"http://example.com/2021/04/05/Matlab%E5%AE%9E%E9%AA%8C2-2/","excerpt":"Matlab实验2-1 Matlab图形操作实验 第5讲例题：5-1，5-3，5-4,5-5,5-6，5-7，5-8,5-9，5-10,5-15","text":"Matlab实验2-1 Matlab图形操作实验 第5讲例题：5-1，5-3，5-4,5-5,5-6，5-7，5-8,5-9，5-10,5-15 5-1：三维螺旋线12345t = 0:0.1:10 * pi;x = t .* sin(t);y = t .* cos(t);z = t;plot3(x, y, z, &#x27;r * -.&#x27;); 5-3：meshgrid网格生成函数123x = [1, 2, 3];y = [4, 7, 9, 10];[X, Y] = meshgrid(x, y) 运行结果 1234567891011121314X = 1 2 3 1 2 3 1 2 3 1 2 3Y = 4 4 4 7 7 7 9 9 9 10 10 10 5-4：“墨西哥帽子”123456x = -8:0.5:8;y = -8:0.5:8;[X, Y] = meshgrid(x, y);r = sqrt(X.^2 + Y.^2) + eps; %会出现r=0的情况，因此加一个eps,eps表示浮点数的最小单位Z = sin(r) ./ r;mesh(X, Y, Z) 5-5：绘制等高线 meshc1234[X, Y] = meshgrid(-8:0.5:8);r = sqrt(X.^2 + Y.^2) + eps;Z = sin(r) ./ r;meshc(X, Y, Z) 5-6：绘制边界面屏蔽 meshz1234[X, Y] = meshgrid(-8:0.5:8);r = sqrt(X.^2 + Y.^2) + eps;Z = sin(r) ./ r;meshz(X, Y, Z) 5-7：画图z=x2+y2,(−3≤x,y≤3)z=x^2+y^2,(-3 \\le x,y \\le 3)z=x2+y2,(−3≤x,y≤3),z=x2−3y2,(−10≤x,y≤10)z=x^2-3y^2,(-10 \\le x,y \\le 10)z=x2−3y2,(−10≤x,y≤10).123456789[X1, Y1] = meshgrid(-3:0.1:3);Z1 = X1.^2 + Y1.^2;subplot(2, 1, 1);mesh(X1, Y1, Z1), title(&#x27;z = x^2 + y^2&#x27;);[X2, Y2] = meshgrid(-10:0.1:10);Z2 = X2.^2 - 3 * Y2.^2;subplot(2, 1, 2)mesh(X2, Y2, Z2), title(&#x27;z = x^2 - 3y^2马鞍面&#x27;) 5-8：ezmesh、ezsurf 函数1234567ezmesh(&#x27;-cos(sqrt(x^2+y^2))&#x27;, [-4, 4], [-4, 4])figureezsurf(&#x27;(6+2*cos(u))*cos(v)&#x27;, &#x27;(6+2*cos(u))*sin(v)&#x27;, &#x27;2 * sin(u)&#x27;, [0, 2 * pi, 0, 2 * pi])hold onezsurf(&#x27;2*sin(u).*cos(v)&#x27;, &#x27;2*sin(u).*sin(v)&#x27;, &#x27;2*cos(u)&#x27;, [0, pi, 0, 2 * pi])axis equalhold off 5-9：画图x2+y2+z2=1x^2+y^2+z^2=1x2+y2+z2=1和x2+y2+z2=4x^2+y^2+z^2=4x2+y2+z2=4的图像.123456v = [-2 2 -2 2 -2 2];subplot(1, 2, 1), sphere(30), axis(v);title(&#x27;半径为1的球面&#x27;);subplot(1, 2, 2), [x, y, z] = sphere(30);surf(2 * x, 2 * y, 2 * z);title(&#x27;半径为2的球面&#x27;); 5-10：柱面作图12345subplot(1, 3, 1), cylinder;subplot(1, 3, 2), cylinder([3, 2]);subplot(1, 3, 3), t = -pi:pi / 10:pi;[x, y, z] = cylinder(1 + sin(t));surf(x, y, z) 5-15：hidden透视控制12345678910[x, y, z] = sphere(50);x1 = 2 * x;y1 = 2 * y;z1 = 2 * z;surf(x, y, z);shading interp;hold onmesh(x1, y1, z1), colormap(hot)hidden off;axis equal; Next⬇️Matlab练习2-3 🍺","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Java三角形类","slug":"Java三角形类","date":"2021-04-01T09:11:43.000Z","updated":"2023-08-25T02:16:39.241Z","comments":true,"path":"2021/04/01/Java三角形类/","link":"","permalink":"http://example.com/2021/04/01/Java%E4%B8%89%E8%A7%92%E5%BD%A2%E7%B1%BB/","excerpt":"Java三角形类已实现的功能： 计算各角度值 计算周长、面积 判断是否可以构成三角形","text":"Java三角形类已实现的功能： 计算各角度值 计算周长、面积 判断是否可以构成三角形 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Triangle &#123; double[] len; double[] degree; private double area, cir; Triangle(double num1, double num2, double num3) &#123; if (num1 + num2 &lt;= num3 || num1 + num3 &lt;= num2 || num2 + num3 &lt;= num1) &#123; System.out.println(&quot;无法构成三角形&quot;); len = null; return; &#125; len = new double[3]; degree = new double[3]; len[0] = num1; len[1] = num2; len[2] = num3; cir = len[0] + len[1] + len[2]; double p = cir / 2; area = Math.sqrt(p * (p - len[0]) * (p - len[1]) * (p - len[2])); //求面积 double a = Math.pow(len[0], 2), b = Math.pow(len[1], 2), c = Math.pow(len[2], 2); degree[0] = Math.toDegrees(Math.acos((a + b - c) / (2 * len[0] * len[1]))); degree[1] = Math.toDegrees(Math.acos((a + c - b) / (2 * len[0] * len[2]))); degree[2] = Math.toDegrees(Math.acos((b + c - a) / (2 * len[1] * len[2]))); &#125; double getArea() &#123; return area; &#125; double getCir() &#123; return cir; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Triangle t = new Triangle(3, 4, 5); System.out.println(&quot;三角形的面积为：&quot; + t.getArea() + &quot;,&quot; + &quot;周长为：&quot; + t.getCir()); System.out.println(&quot;三角度数为：&quot; + t.degree[0] + &quot;,&quot; + t.degree[1] + &quot;,&quot; + t.degree[2]); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Matlab实验2-1","slug":"Matlab实验2-1","date":"2021-04-01T03:32:28.000Z","updated":"2023-08-25T03:14:14.713Z","comments":true,"path":"2021/04/01/Matlab实验2-1/","link":"","permalink":"http://example.com/2021/04/01/Matlab%E5%AE%9E%E9%AA%8C2-1/","excerpt":"Matlab实验2-1 Matlab图形操作实验 第4讲例题：4-1，4-2，4-5，4-6，4-7","text":"Matlab实验2-1 Matlab图形操作实验 第4讲例题：4-1，4-2，4-5，4-6，4-7 4-1：画y=sin(x+3)y=sin(x+3)y=sin(x+3)和y=exp(sin(x))y=exp(sin(x))y=exp(sin(x))的图像.1234x = -2 * pi:0.1:2 * pi;y1 = sin(x + 3);y2 = exp(sin(x));plot(x, y1, &#x27;-*&#x27;, x, y2, &#x27;:o&#x27;) %&#x27;-&#x27;表示实线，&#x27;*&#x27;表示以*标注；&#x27;：&#x27;表示点线，&#x27;o&#x27;表示用圆圈标出数据点 4-2：用不同标度在同一坐标绘制曲线y1=200e−0.05xsinxy_{1}=200e^{-0.05x}sinxy1​=200e−0.05xsinx和y2=0.8e−0.5xsin10xy_{2}=0.8e^{-0.5x}sin10xy2​=0.8e−0.5xsin10x123456x = 0:0.1:20;y1 = 200 * exp(-0.05 * x) .* sin(x); %要用.*y2 = 0.8 * exp(-0.5 * x) .* sin(10 * x);plot(x, y1, x, y2); %plot只有一个坐标轴，plotyy则有两个坐标轴legend(&#x27;y_1=200e^&#123;-0.05x&#125;sinx&#x27;, &#x27;y_2=0.8e^&#123;-0.5x&#125;sin10x&#x27;); %LaTex 4-5：绘制r=sint∗costr=sint*costr=sint∗cost的极坐标图.123t = 0:pi / 50:2 * pi;r = sin(t) .* cos(t);polar(t, r, &#x27;dc&#x27;); %d表示菱形，c表示青色 4-6：subplot划分画图区域123456789%将一个绘图窗口分割成m*n个子区域，并按行从左至右依次编号.p表示第p个绘图子区域.%subplot(&#x27;Position&#x27;,[left,bottom,width,height])x = -2:0.2:2;y1 = x + sin(x);y2 = sin(x) ./ x;y3 = (x.^2);subplot(2, 2, 1), plot(x, y1, &#x27;m.&#x27;); %&#x27;m&#x27;表示洋红，&#x27;.&#x27;表示用点标出数据点subplot(2, 2, 2), plot(x, y2, &#x27;rp&#x27;); %&#x27;r&#x27;表示红色，&#x27;p&#x27;表示五角星subplot(&#x27;position&#x27;, [0.2, 0.05, 0.6, 0.45]), plot(x, y3) 4-7：legend 添加图例1234567891011121314x = 0:0.2:2 * pi;hold onplot(x, cos(x), &#x27;r+:&#x27;);plot(x, sin(x), &#x27;bd-.&#x27;);plot(x, 2 * cos(x), &#x27;kh-&#x27;);legend(&#x27;cos(x)&#x27;, &#x27;sin(x)&#x27;, &#x27;2cos(x)&#x27;)xlabel(&#x27;x&#x27;);ylabel(&#x27;y&#x27;);title(&#x27;几种三角函数图像比较&#x27;)text(0.7, 1.7, &#x27;\\leftarrow 2cos(x)&#x27;);text(2.7, 0.6, &#x27;\\leftarrow sin(x)&#x27;);text(2.2, -0.5, &#x27;\\leftarrow cos(x)&#x27;)hold offgtext(&#x27;真好!&#x27;) Next⬇️Matlab练习2-2 🍺","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Java—abstract类与继承","slug":"Java—abstract类与继承","date":"2021-03-31T03:06:01.000Z","updated":"2023-08-25T03:14:17.217Z","comments":true,"path":"2021/03/31/Java—abstract类与继承/","link":"","permalink":"http://example.com/2021/03/31/Java%E2%80%94abstract%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"抽象类 abstract类不能使用new建立对象，只能作为父类 抽象方法中没有方法体，包含抽象方法的类一定要为抽象类 abstract方法必须在子类中重写","text":"抽象类 abstract类不能使用new建立对象，只能作为父类 抽象方法中没有方法体，包含抽象方法的类一定要为抽象类 abstract方法必须在子类中重写 1234567891011121314151617181920212223242526272829303132abstract class shape &#123; protected String name; double s, v; public abstract String getName();&#125;class ball extends shape &#123; private double r; public String getName() &#123; return ball.super.name; &#125; ball(double r, String name) &#123; this.r = r; this.name = name; s = 4 * Math.PI * Math.pow(r, 2); v = 4 * Math.PI * Math.pow(r, 3) / 3; &#125; public double getVolume() &#123; return v; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ball c = new ball(2, &quot;MyBall&quot;); System.out.println(c.getName() + &quot;\\t&quot; + c.getVolume()); &#125;&#125; 多态123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void work() &#123; System.out.println(&quot;看家&quot;); &#125; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"泰勒级数展开求解e的x次方","slug":"泰勒级数展开求解e的x次方","date":"2021-03-25T09:40:23.000Z","updated":"2023-08-25T03:23:05.920Z","comments":true,"path":"2021/03/25/泰勒级数展开求解e的x次方/","link":"","permalink":"http://example.com/2021/03/25/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80%E6%B1%82%E8%A7%A3e%E7%9A%84x%E6%AC%A1%E6%96%B9/","excerpt":"泰勒级数展开求解e的x次方","text":"泰勒级数展开求解e的x次方 根据公式ex=lim⁡n→+∞1+x+x22!+⋅⋅⋅+xnx!e^x = \\lim\\limits_{n\\to+\\infty} 1 + x + \\frac{x^2}{2!} + ··· +\\frac{x^n}{x!}ex=n→+∞lim​1+x+2!x2​+⋅⋅⋅+x!xn​ 1234567891011121314public class Main &#123; public static double CalE(int x) &#123; double ans = 1, s = x; for (int i = 2; i &lt; 100; i++) &#123; ans += s; s = s * x * 1.0 / i; &#125; return ans; &#125; public static void main(String[] args) &#123; System.out.printf(&quot;%.8f&quot;, CalE(1)); //CalE(x)即为e的x次方 &#125;&#125; 加入判断条件12345678910111213141516import java.math.*;public class Main &#123; public static double CalE(int x) &#123; double ans = 1, s = x; for (int i = 2; s &gt; 1e-8; i++) &#123; ans += s; s = s * x * 1.0 / i; &#125; return ans; &#125; public static void main(String[] args) &#123; System.out.printf(&quot;%.8f&quot;, CalE(1)); &#125;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Java矩阵操作","slug":"Java矩阵操作","date":"2021-03-18T05:15:39.000Z","updated":"2023-08-25T03:27:04.054Z","comments":true,"path":"2021/03/18/Java矩阵操作/","link":"","permalink":"http://example.com/2021/03/18/Java%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/","excerpt":"Java 矩阵转置矩阵转置函数返回一个二维数组，而不改变原有数组","text":"Java 矩阵转置矩阵转置函数返回一个二维数组，而不改变原有数组 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static int[][] ReserveMat(int[][] matrix) &#123; int m=matrix.length, n=matrix[0].length; int[][] newMatrix=new int[m][n]; for (int i = 0; i &lt; m ; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; newMatrix[i][j]=matrix[m-i-1][n-j-1]; &#125; &#125; return newMatrix; &#125; public static void print(int[][] m) &#123; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; System.out.print(m[i][j] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; System.out.println(&quot;原矩阵：&quot;); print(matrix); int[][] newMatrix= ReserveMat(matrix); System.out.println(&quot;转换后的矩阵：&quot;); print(newMatrix); System.out.println(&quot;原来的的矩阵：&quot;); print(matrix); &#125;&#125; 矩阵相加123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static int[][] PlusMat(int[][] matrix1, int[][] matrix2) &#123; int m1 = matrix1.length, n1 = matrix1[0].length; int m2 = matrix2.length, n2 = matrix2[0].length; int[][] newMatrix = new int[m1][n1]; if ((m1 != m2) || (n1 != n2)) &#123; System.out.println(&quot;两矩阵行列不一致，无法相加&quot;); return null; &#125; else &#123; for (int i = 0; i &lt; m1; i++) &#123; for (int j = 0; j &lt; n1; j++) &#123; newMatrix[i][j] = matrix1[i][j] + matrix2[i][j]; &#125; &#125; &#125; return newMatrix; &#125; public static void print(int[][] m) &#123; for (int i = 0; i &lt; m.length; i++) &#123; for (int j = 0; j &lt; m[i].length; j++) &#123; System.out.print(m[i][j] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125; public static void main(String[] args) &#123; int[][] matrix1 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int[][] matrix2 = &#123;&#123;2, 3, 4&#125;, &#123;5, 6, 7&#125;, &#123;8, 9, 10&#125;&#125;; int[][] newMatrix; System.out.println(&quot;矩阵相加\\nMatrix1:&quot;); print(matrix1); System.out.println(&quot;Matrix2&quot;); print(matrix2); System.out.println(&quot;相加后的结果&quot;); newMatrix = PlusMat(matrix1, matrix2); if (newMatrix != null) &#123; print(newMatrix); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"百鸡问题","slug":"百鸡问题","date":"2021-03-16T15:22:57.000Z","updated":"2023-08-25T02:16:39.251Z","comments":true,"path":"2021/03/16/百鸡问题/","link":"","permalink":"http://example.com/2021/03/16/%E7%99%BE%E9%B8%A1%E9%97%AE%E9%A2%98/","excerpt":"百鸡问题：公鸡5¥&#x2F;只，母鸡3¥&#x2F;只，小鸡3只&#x2F;¥，若100¥买100只鸡，问其中公鸡、母鸡、小鸡各多少？","text":"百鸡问题：公鸡5¥&#x2F;只，母鸡3¥&#x2F;只，小鸡3只&#x2F;¥，若100¥买100只鸡，问其中公鸡、母鸡、小鸡各多少？ 解法一：直接计算123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; int k; boolean isAns = false; for (int i = 1; i &lt; 20; i++) &#123; //i表示公鸡个数 for (int j = 1; j &lt; 33; j++) &#123; //j表示母鸡个数 k = 100 - i - j; //k/3表示小鸡个数 if ((k % 3 == 0) &amp;&amp; (5 * i + 3 * j + k / 3 == 100)) &#123; System.out.println(&quot;公鸡&quot; + i + &quot;只，母鸡&quot; + j + &quot;只，小鸡&quot; + k + &quot;只&quot;); isAns = true; &#125; &#125; &#125; if (!isAns) &#123; System.out.println(&quot;问题无解！&quot;); &#125; &#125;&#125; 解法二：返回类型为二维数组123456789101112131415161718192021222324252627282930public class Main &#123; public static int[][] f() &#123; //计算的函数，返回类型为二维数组 int k, row = 1; int[][] ans = new int[20][3]; for (int i = 1; i &lt; 20; i++) &#123; //i表示公鸡个数 for (int j = 1; j &lt; 33; j++) &#123; //j表示母鸡个数 k = 100 - i - j; //k/3表示小鸡个数 if ((k % 3 == 0) &amp;&amp; (5 * i + 3 * j + k / 3 == 100)) &#123; ans[row][0] = i; ans[row][1] = j; ans[row][2] = k; row++; &#125; &#125; &#125; ans[0][0] = row; return ans; &#125; public static void main(String[] args) &#123; int[][] ans = f(); for (int i = 1; i &lt; ans[0][0]; i++) &#123; System.out.println(&quot;公鸡&quot; + ans[i][0] + &quot;只，母鸡&quot; + ans[i][1] + &quot;只，小鸡&quot; + ans[i][2] + &quot;只&quot;); System.out.println(); &#125; if (ans[0][0] == 0) &#123; System.out.println(&quot;本题无解！&quot;); &#125; &#125;&#125; 运行结果 12345公鸡4只，母鸡18只，小鸡78只公鸡8只，母鸡11只，小鸡81只公鸡12只，母鸡4只，小鸡84只Process finished with exit code 0","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"OS结构设计P.24-P.33","slug":"OS结构设计P-24-P-33","date":"2021-03-16T02:46:26.000Z","updated":"2023-08-25T02:16:39.245Z","comments":true,"path":"2021/03/16/OS结构设计P-24-P-33/","link":"","permalink":"http://example.com/2021/03/16/OS%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1P-24-P-33/","excerpt":"OS结构设计——读书报告 传统操作系统结构 无结构操作系统 模块化结构OS 分层式结构OS","text":"OS结构设计——读书报告 传统操作系统结构 无结构操作系统 模块化结构OS 分层式结构OS 无结构操作系统特点： 复杂且混乱，无结构，被称为整体系统结构 每个过程可以任意地相互调用其他过程 模块化结构OS 模块化程序设计级数的基本概念 操作系统 进程管理 进程控制 进程调度 ··· 存储器管理 内存分配 内存保护 文件管理 磁盘管理 目录管理 模块独立性 内聚性，指模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越强。 耦合度，指模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。 模块接口法的优缺点 优点 提高OS设计的正确性、可理解性和可维护性 增强OS的可适应性 加速OS的开发过程 缺点 各模块接口规定很难满足设计完成之后对接口的实际需求 设计时，各模块设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的无序性 分层式结构OS 分层式结构的基本概念 将“决定顺序”的无序性变为有序性 基本原则：每一层设计都建立在可靠的基础之上 每一层仅能使用其底层所提供的功能和服务 分层结构的优缺点 优点 易保证系统的正确性 易扩充和易维护性 缺点 系统效率降低 客户&#x2F;服务器模式（Client&#x2F;Server Model）简介客户&#x2F;服务器模式模式由来、组成和类型 客户机： 服务器 网络系统 客户&#x2F;服务器之间的交互 客户发送请求消息 服务器接收消息 服务器回送消息 客户机接收消息 客户&#x2F;服务器模式的优点 数据的分布处理和存储 便于集中管理 灵活性和可扩充性 易于改编应用软件 面向对象的程序设计（Object-Orientated Programming）技术简介面向对象的基本概念 对象 对象类 继承 面向对象技术的优点 通过重用提高产品质量和生产率 使系统具有更好的易修改性和易扩展性 更易于保证系统的正确性和可靠性 微内核OS结构微内核操作系统的基本概念 足够小的内核 基于客户&#x2F;服务器模式 应用机制与策略分离原理 采用面向对象技术 微内核的基本功能 进程（线程）管理 低级存储管理 中断和陷入处理 微内核操作系统的优点 提高了系统的可扩展性 增强了系统的可靠性 可移植性强 提供对分布式系统的支持 融入了面向对象技术 微内核操作系统存在的问题较之早期的操作系统，运行效率较低","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第四节 操作系统的特征","slug":"第四节-操作系统的特征","date":"2021-03-16T02:17:42.000Z","updated":"2023-08-25T02:16:39.251Z","comments":true,"path":"2021/03/16/第四节-操作系统的特征/","link":"","permalink":"http://example.com/2021/03/16/%E7%AC%AC%E5%9B%9B%E8%8A%82-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/","excerpt":"操作系统的特征操作系统的四大基本特征： 并发 共享 虚拟 异步 并发和并行的区别并行是一种物理的、微观的同时性概念并发是一种逻辑的、宏观的同时性概念","text":"操作系统的特征操作系统的四大基本特征： 并发 共享 虚拟 异步 并发和并行的区别并行是一种物理的、微观的同时性概念并发是一种逻辑的、宏观的同时性概念 单处理机不可能实现并行，但可以实现并发。多处理机系统既可以实现并行，也可以实现并发并发，指的是多个事情，在同一时间段内同时发生了。并行，指的是多个事情，在同一时间点上同时发生了。并发的多个任务之间是互相抢占资源的。 并行的多个任务之间是不互相抢占资源的、 只有在多cpu的情况中，才会发生并行。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Mac虚拟机安装指北(适用于Big Sur及Catalina)","slug":"Mac虚拟机安装指北-适用于Big-Sur及Catalina","date":"2021-03-14T02:30:55.000Z","updated":"2023-08-25T02:16:39.243Z","comments":true,"path":"2021/03/14/Mac虚拟机安装指北-适用于Big-Sur及Catalina/","link":"","permalink":"http://example.com/2021/03/14/Mac%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97-%E9%80%82%E7%94%A8%E4%BA%8EBig-Sur%E5%8F%8ACatalina/","excerpt":"Mac虚拟机安装指北(适用于Big Sur及Catalina)声明 本文部分内容转载自CSDN「红叶枫」的博文，遵循CC 4.0 BY-SA版权协议：原文地址 本文部分内容转载自CSDN「繁星蓝雨」的博文，遵循CC 4.0 BY-SA版权协议：原文地址 本文仅作学习交流参考，请支持正版 所需工具下载地址","text":"Mac虚拟机安装指北(适用于Big Sur及Catalina)声明 本文部分内容转载自CSDN「红叶枫」的博文，遵循CC 4.0 BY-SA版权协议：原文地址 本文部分内容转载自CSDN「繁星蓝雨」的博文，遵循CC 4.0 BY-SA版权协议：原文地址 本文仅作学习交流参考，请支持正版 所需工具下载地址 PD16：适用于M1以及安装了Big Sur系统的Intel芯片Mac 百度网盘下载 提取码：4wod PD15：适用于未升级至Big Sur的Intel芯片Mac 百度网盘下载 提取码：e5bs Windows10 ISO下载 官网下载 ED2K下载(复制并打开迅雷，即可自动下载)ed2k://|file|cn_windows_10_consumer_editions_version_20h2_updated_feb_2021_x64_dvd_8ddab99d.iso|6223781888|954B729026D6E420EE46FB2DC912F256|/ M1 Mac以及Big Sur Mac在安装PD16时可能遇到的问题网络初始化失败 解决办法： 前往 &#x2F;Library&#x2F;Preferences&#x2F;Parallels目录 打开network.desktop.xml文件 找到&lt;UseKextless&gt;1&lt;/UseKextless&gt;或&lt;UseKextless&gt;-1&lt;/UseKextless&gt;, 修改为&lt;UseKextless&gt;0&lt;/UseKextless&gt; 如果找不到这个标记，那么就在根标记下创建它，如下：1234&lt;ParallelsNetworkConfig&gt; &lt;!-- 新增 --&gt; &lt;UseKextless&gt;0&lt;/UseKextless&gt;&lt;/ParallelsNetworkConfig&gt; USB 问题解决办法： 前往&#x2F;Library&#x2F;Preferences&#x2F;Parallels文件夹 打开 dispatcher.desktop.xml文件 找到&lt;Usb&gt;0&lt;/Usb&gt;，修改为&lt;Usb&gt;1&lt;/Usb&gt; 弹窗问题 进入Windows系统后，可能会出现下面的弹窗 解决办法 下载配置文件：[下载地址] 提取码：c7u0 打开任务管理器，在进程一栏下拉，找到Parallels Control Center，选中该进程，并结束任务 前往目录C：\\ Program Files（x86）\\ Parallels \\ Parallels Tools \\ Plugins \\，并将下载的文件拖入到该文件夹中，在弹出的提示窗口中选择替换 重启Windows","categories":[],"tags":[{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"分时操作系统与实时操作系统的比较","slug":"分时操作系统与实时操作系统的比较","date":"2021-03-12T06:47:05.000Z","updated":"2023-08-25T02:16:39.249Z","comments":true,"path":"2021/03/12/分时操作系统与实时操作系统的比较/","link":"","permalink":"http://example.com/2021/03/12/%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"3.19操作系统作业分时操作系统与实时操作系统的比较简介 计算机操作系统从20世纪50年代中期第二代计算机的单道批处理系统到20世纪60年代中期第三代计算机的多道批处理系统（IBM公司研发的OS&#x2F;360系统是第一个能运行多道程序的批处理系统），都主要致力于提高资源利用率和系统吞吐量。但人们对人机交互的需求却一直未能得到有效解决，因此一种新型OS——分时OS就应运而生了，紧接着实时OS也在工业、军事等领域的需求下也随之诞生。现在我们所使用的操作系统都属于这两类。","text":"3.19操作系统作业分时操作系统与实时操作系统的比较简介 计算机操作系统从20世纪50年代中期第二代计算机的单道批处理系统到20世纪60年代中期第三代计算机的多道批处理系统（IBM公司研发的OS&#x2F;360系统是第一个能运行多道程序的批处理系统），都主要致力于提高资源利用率和系统吞吐量。但人们对人机交互的需求却一直未能得到有效解决，因此一种新型OS——分时OS就应运而生了，紧接着实时OS也在工业、军事等领域的需求下也随之诞生。现在我们所使用的操作系统都属于这两类。 分时操作系统为解决批处理系统中无交互手段、调试程序困难等缺点，出现了分时操作系统。工作方式 一台主机连接了若干个终端 每个终端（近程或远程）有一个用户在使用 每个用户交互式地向系统提出命令请求 系统接收每个用户的命令 采用时间片轮转方式处理各用户的服务请求 通过交互方式在终端上向用户显示结果 用户根据上步结果发出下道命令 分时操作系统实现（条件）关键：及时接受、及时处理 系统中配置多路卡，以便主机及时接收各用户输入的命令或数据 每个终端配备缓存，以便暂存用户数据 用户作业直接输入内存，可确保系统及时响应用户要求 采用时间片轮转法，使一台主机同时为多个用户服务，且保证足够快的响应时间 时间片操作系统将CPU的时间划分成若干各片段，称为时间片 时间片轮转法操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片。其特点是利用人的错觉，使人感觉不到。 特点 多路性 交互性 独立性 及时性 典型的分时系统是MUTICS和UNIX 实时操作系统能及时响应外部事件的请求，在规定时限内完成对该事件的处理。分类 第一类：实施过程控制系统 工业控制、军事控制 第二类：实时通信（信息）处理系统 电讯、银行、飞机订票、股市行情 多媒体系统 将文本、图像、音频、视频等信息集中在一个文件中，形成多媒体文件。多媒体播放系统必须为实时处理系统。 嵌入式系统 嵌入在各智能仪器和设备中的芯片，可对设备进行控制或对其中信息做处理，需要实时控制或处理。 主要追求目标 对外部请求在严格时间范围内作出反应（及时响应） 高可靠性（采用双工制：两台完全相同的计算机） 安全性 完整性 特点 多路性 交互性 独立性 及时性 可靠性 分时系统与实时系统比较 多路性：两者都具有多路性。软实时与分时系统中的多路性表现为系统按分时原则为多个任务终端用户服务；硬实时则指系统周期性地对多路现场信息进行采集以及对多个对象或多个执行机构进行控制。 独立性：两者都具有独立性。每个终端用户在向分时系统提出服务请求时，是彼此独立的操作，互不干扰；而在实时控制系统中信息的采集和对对象的控制，也彼此互不干扰。 及时性：实时信息系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，则是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级、百毫秒级直至毫秒级，甚至有的要低于100微秒。 交互性：实时信息处理系统具有交互性，但这里人与系统的交互，仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理服务、资源共享等服务。 可靠性：分时系统要求系统可靠，相比之下，实时系统则要求系统高度可靠。因为任何差错都可能带来巨大的经济损失甚至无法预料的灾难性后果。因此，在实时系统中，采取了多级容错措施来保证系统的安全及数据的安全。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Java指北","slug":"Java指北","date":"2021-03-11T08:53:26.000Z","updated":"2023-08-25T02:16:39.241Z","comments":true,"path":"2021/03/11/Java指北/","link":"","permalink":"http://example.com/2021/03/11/Java%E6%8C%87%E5%8C%97/","excerpt":"Java指北 Java的工作方式 安装JDK 确认java与javac添加到环境变量中 新建name.java，并使用文本编辑器进行编辑(推荐使用NotePad++或者是SublimeText) 在命令行中使用javac对name.java进行编译，并使用java命令运行生成的name.class(注意路径是否正确)编译前记得先保存","text":"Java指北 Java的工作方式 安装JDK 确认java与javac添加到环境变量中 新建name.java，并使用文本编辑器进行编辑(推荐使用NotePad++或者是SublimeText) 在命令行中使用javac对name.java进行编译，并使用java命令运行生成的name.class(注意路径是否正确)编译前记得先保存 注意的事情 文件名与主类名相同，比如demo.java对应的主类应为public class java&#123;&#125; 在主类中，应该有main方法作为程序开始的入口，若没有main方法，可以通过编译但无法运行 main方法中必须有String类型的字符串数组,数组名无所谓，但习惯上使用String[] args String与System等关键字大小写敏感 String[] array;与String array[];都是可以的 boolean与int本身不支持强制转换，因此结果为非boolean的表达式放入if或者是while中会报错 Java中的运算符%为取余，即结果与左操作符具有相同的符号，这一点与C++相同，举个栗子123System.out.println(-4%-3);System.out.println(4%-3);System.out.println(-4%3); 运行结果 123-11-1 取模的运算结果在不同的环境下具有不同的意义，举一个Matlab的栗子123456789101112131415161718&gt;&gt; mod(-4,-3) ans = -1&gt;&gt; mod(-4,3) ans = 2&gt;&gt; mod(4,-3) ans = -2 一些小技巧 Java提供了一种主要用于数组的增强型for循环12345678910111213141516public class demo &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(&quot;,&quot;); &#125; System.out.print(&quot;\\n&quot;); String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(&quot;,&quot;); &#125; &#125;&#125; 运行结果为 1210,20,30,40,50,James,Larry,Tom,Lacy, 持续更新中🍺","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JavaDemo","slug":"JavaDemo","date":"2021-03-10T12:35:19.000Z","updated":"2023-08-25T03:26:52.600Z","comments":true,"path":"2021/03/10/JavaDemo/","link":"","permalink":"http://example.com/2021/03/10/JavaDemo/","excerpt":"Java Demo 一个Java的Demo，用以显示一个表格","text":"Java Demo 一个Java的Demo，用以显示一个表格 123456789101112131415161718192021222324252627282930313233343536373839import java.awt.*;import javax.swing.*;public class TableDemoMVC extends JFrame&#123; TableDemoMVC()&#123; init(); &#125; protected void init()&#123; Container ct; final String[] columnNames=&#123;&quot;姓名&quot;,&quot;职位&quot;,&quot;电话&quot;,&quot;月薪&quot;,&quot;婚否&quot;&#125;; final Object[][] data=&#123; &#123;&quot;王东&quot;,&quot;总经理&quot;,&quot;0191123823&quot;,new Integer(5000),new Boolean(false)&#125;, &#123;&quot;李宏&quot;,&quot;秘书&quot;,&quot;0191123824&quot;,new Integer(3500),new Boolean(true)&#125;, &#123;&quot;李瑞&quot;,&quot;开发&quot;,&quot;0191123825&quot;,new Integer(4500),new Boolean(false)&#125;, &#123;&quot;赵新&quot;,&quot;保卫&quot;,&quot;0191123826&quot;,new Integer(2000),new Boolean(true)&#125;, &#123;&quot;陈理&quot;,&quot;销售&quot;,&quot;0191123827&quot;,new Integer(4000),new Boolean(false)&#125;, &#125;; JTable table=new JTable(data,columnNames); this.setSize(new Dimension(500,230)); JScrollPane jp=new JScrollPane(table); ct=getContentPane(); ct.add(jp); &#125; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException&#123; try &#123; UIManager.setLookAndFeel(&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;Look and Feel not set&quot;); &#125; TableDemoMVC frame=new TableDemoMVC(); frame.setVisible(true); &#125;&#125; 一个Java的Demo，用以显示一带有背景的窗口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.awt.*;import java.awt.event.*;import java.util.Scanner;import javax.swing.JFrame;public class Main extends JFrame &#123; public Main() &#123; setSize(1000, 650); setDefaultCloseOperation(EXIT_ON_CLOSE); setLocationRelativeTo(null); &#125; public void paint(Graphics g) &#123; g.setColor(Color.white); Image img = Toolkit.getDefaultToolkit().getImage(&quot;test.jpg&quot;); //用你的图片加以替换 g.drawImage(img, 0, 0, this.getWidth(), this.getHeight(), Color.LIGHT_GRAY, this); g.fillRoundRect(120, 120, 300, 100, 40, 40); g.setColor(Color.CYAN); g.drawRoundRect(100, 100, 300, 100, 40, 40); g.setFont(new Font(&quot;Helvetica&quot;, Font.PLAIN, 30)); g.setColor(Color.CYAN); g.drawString(&quot;Hello world!&quot;, 150, 150); &#125; public static void main(String[] args) &#123; Frame f = new Main(); Button b = new Button(&quot;一个按钮&quot;); Label l = new Label(&quot;标签&quot;); b.setBounds(100, 250, 100, 30); b.setFont(new Font(&quot;仿宋&quot;, Font.PLAIN, 10)); l.setBounds(100, 200, 60, 30); f.add(l); f.add(b); f.setSize(1000, 650); f.setResizable(false); f.setLayout(null); f.setVisible(true); b.addActionListener(new ActionListener() &#123; int count = 0; public void actionPerformed(ActionEvent e) &#123; Toolkit.getDefaultToolkit().beep(); int cnt = ((count++) % 2); switch (cnt) &#123; case 0: l.setBackground(Color.white); l.setForeground(Color.BLACK); break; case 1: l.setBackground(Color.BLACK); l.setForeground(Color.white); break; &#125; &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"demo","slug":"demo","permalink":"http://example.com/tags/demo/"}]},{"title":"Matlab实验1-3","slug":"Matlab实验1-3","date":"2021-03-07T13:30:24.000Z","updated":"2023-08-25T02:16:39.244Z","comments":true,"path":"2021/03/07/Matlab实验1-3/","link":"","permalink":"http://example.com/2021/03/07/Matlab%E5%AE%9E%E9%AA%8C1-3/","excerpt":"Matlab计算圆周率欧拉级数 收敛速度较慢形式较为雅观","text":"Matlab计算圆周率欧拉级数 收敛速度较慢形式较为雅观 Euler.m 123456789101112131415format long;t = 9e7;d = 1;while d &gt;= 1e-10 if d&lt;=1e-9 t = t + 100; else t = t + 100000; end mypi = sqrt(6 * EulerSum(t)) d = abs(pi - mypi)endt EulerSum.m 1234567891011function y = EulerFunc(n) sum = 1; for index = 2:n sum = sum + 1 / (index^2); end y = sum; returnend 另一种计算方式： Euler2.m 12345678910111213format long;t = 0;d = 1;s=0;while d &gt;= 1e-10 t = t + 1; s=s+1/(t^2); mypi = sqrt(6 * s) d = abs(pi - mypi);endt 拉马努金级数 收敛速度极快只需计算一两步即可到达1e-8的精度 1234567891011121314format long;n = 0;d = 1;s = 0;sqrt_int = (2 * sqrt(2)) / 9801;while d &gt;= 1e-8 s = s + (factorial(4 * n) * (1103 + 26390 * n)) / ((factorial(n)^4) * ((396)^(4 * n))); mypi = (sqrt_int * s)^(- 1) d = abs(pi - mypi) n = n + 1;endn 莱布尼茨公式π4=1−13+15−17+⋅⋅⋅\\frac{\\pi}4=1-\\frac13+\\frac15-\\frac17+\\cdot\\cdot\\cdot4π​=1−31​+51​−71​+⋅⋅⋅ 1234567891011121314format long;d = 1;t = 0;s = 0;mypi = 0;while d &gt;= 1e-2 s = s + ((-1)^t*(1/(2*t+1))); mypi = 4 * s d = abs(pi - mypi); t = t + 1;endt E N D","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Matlab实验1-2","slug":"Matlab实验1-2","date":"2021-03-04T06:32:58.000Z","updated":"2023-08-25T03:27:11.362Z","comments":true,"path":"2021/03/04/Matlab实验1-2/","link":"","permalink":"http://example.com/2021/03/04/Matlab%E5%AE%9E%E9%AA%8C1-2/","excerpt":"Matlab实验1-2 测试矩阵的:操作，要求把测试的过程和结果放入实验报告.","text":"Matlab实验1-2 测试矩阵的:操作，要求把测试的过程和结果放入实验报告. 123456A = randi(5, 3, 4)A(5)A(2, 3)%row=2,col=3A(3, :)%row=3A(:, 1) = [ ]%delet first col 运算结果 1234567891011121314151617181920212223242526272829&gt;&gt; TestColon A = 4 1 4 3 2 3 4 3 5 2 1 4ans = 3ans = 4ans = 5 2 1 4A = 1 4 3 3 4 3 2 1 4 测试字符串操作. 123456789101112str = &#x27;a+b,c+d,&#x27;n = findstr(str, &#x27;,&#x27;)%n1是第一个&quot;,&quot;(4),n2是第二个&quot;, &quot;(8)str1 = str(1:n(1))str2 = str(n(1) + 1:n(2))str3 = strrep(str1, &#x27;,&#x27;, &#x27;*2&#x27;)%str replacea = 5b = 2c = 3d = 4eval(str1)%计算str1的值eval(str3)%计算str3的值str2 = upper(str2) 运算结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt;&gt; TestStr str = &#x27;a+b,c+d,&#x27;n = 4 8str1 = &#x27;a+b,&#x27;str2 = &#x27;c+d,&#x27;str3 = &#x27;a+b*2&#x27;a = 5b = 2c = 3d = 4ans = 7ans = 9str2 = &#x27;C+D,&#x27; 已知f(n)=1+13+15+⋅⋅⋅+12n−1f(n)=1+\\frac{1}{3}+\\frac{1}{5}+···+\\frac{1}{2n-1}f(n)=1+31​+51​+⋅⋅⋅+2n−11​分别用for循环和while循环编写两个函数，并计算f(50)f(50)f(50),f(100)f(100)f(100),f(200)f(200)f(200)的值. CalFunc.m 123function y=F(x) y=1/(2*x);end Cal.m 12345678910111213141516171819202122232425sum = 0;for index = 1:50 sum = sum + CalFunc(index);enddisp(&#x27;f(50)=&#x27;)sumsum=0;for index = 1:100 sum = sum + CalFunc(index);enddisp(&#x27;f(100)=&#x27;)sumsum=0;for index = 1:200 sum = sum + CalFunc(index);enddisp(&#x27;f(200)=&#x27;)sumsum=0; 运算结果 123456789101112131415161718&gt;&gt; Calf(50)=sum = 2.249602669164712f(100)=sum = 2.593688758819810f(200)=sum = 2.939015474060723 查阅测试excel文件的读取和写入函数xlsread,xlswrite，要求把测试的过程和结果放入实验报告. 123num=xlsread(&quot;Book1.xls&quot;)num(:,1)=[ ]xlswrite(&quot;Book1.xls&quot;,num,&#x27;A5&#x27;) 运行结果 12345678910111213141516171819&gt;&gt; Testxlsnum = 3 4 6 3 2 5 9 7 5 3 4 0 6 4 3num = 4 6 3 2 9 7 5 3 0 6 4 3Warning: Could not start Excel server for export.XLSWRITE will attempt to write file in CSV format. &gt; In xlswrite (line 181) In Testxls (line 3) 出现了无法写入的问题，num被写入到了新建的Book1.csv，而非原有的Book1.xls。此问题仅存在于macOS，原因为macOS上的Office目前不支持COM接口，目前无解。 自己编写矩阵左右翻转、上下翻转函数，不得使用Matlab已经编写好的左右翻转和上下翻转函数。给一个具体的矩阵并做测试翻转. 123A = magic(4)MatrixReserveFunc1(A)MatrixReserveFunc2(A) MatrixReserveFunc1.m 1234567891011function MatrixReserveFunc1(A) [m, n] = size(A); for row = 1:m / 2 temp = A(row, :); A(row, :) = A(m - row + 1, :); A(m - row + 1, :) = temp; end Aend MatrixReserveFunc2.m 1234567891011function MatrixReserveFunc2(A) [m, n] = size(A); for col = 1:n / 2 temp = A(:, col); A(:, col) = A(:, n - col + 1); A(:, n - col + 1) = temp; end Aend 运行结果 123456789101112131415161718192021222324&gt;&gt; MatrixReserveA = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1A = 4 14 15 1 9 7 6 12 5 11 10 8 16 2 3 13A = 13 3 2 16 8 10 11 5 12 6 7 9 1 15 14 4 编写函数，计算1!+2!+⋅⋅⋅+20!1!+2!+···+20!1!+2!+⋅⋅⋅+20!和1!+2!+⋅⋅⋅+30!1!+2!+···+30!1!+2!+⋅⋅⋅+30! TestFactorFunc.m 123456789101112131415function y = TestFactorFunc(n) fac = 1; s = 0; for index1 = 1:n for index2 = 1:index1 fac = fac * index2; end s = s + fac; fac = 1; end y = s;end TestFactor.m 12345disp(&#x27;Factor(20)=&#x27;)sum=TestFactorFunc(20)disp(&#x27;Factor(30)=&#x27;)sum=TestFactorFunc(30) 运行结果 123456789101112&gt;&gt; TestFactorFactor(20)=sum = 2.5613e+18Factor(30)=sum = 2.7441e+32 编写斐波那契（Fibonacci）数列的函数，列出数列前40个数.提示：可以递归调用，也可以把数列的数放入数组中存储. TestFib.m 12345A=[ ]for index = 1:40 A=[A,TestFibFunc(index)];endA TestFibFunc.m 1234567891011function y = Fib(n) A(1) = 1; A(2) = 1; for i = 3:n A(i) = A(i - 1) + A(i - 2); end y = A(n); returnend 运行结果 12345678910111213141516171819202122232425262728&gt;&gt; TestFibA = [ ]A = Columns 1 through 9 1 1 2 3 5 8 13 21 34 Columns 10 through 18 55 89 144 233 377 610 987 1597 2584 Columns 19 through 27 4181 6765 10946 17711 28657 46368 75025 121393 196418 Columns 28 through 36 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 Columns 37 through 40 24157817 39088169 63245986 102334155 编写课件中的猜数游戏，并做测试. 首先由计算机随机产生一个[1,100][1,100][1,100]之间的一个整数，然后由用户猜测所产生的这个数。根据用户猜测的情况给出不同的提示，如果猜测的数大于产生的数，则显示High，小于则显示Low，等于则显示You won!，同时退出游戏。用户最多有 10 次机会. 123456789101112131415161718192021fprintf(&quot;游戏开始！\\n请输入你猜的数\\n&quot;)num=randi(100)t=10;while t&gt;0 t=t-1; x=input(&#x27;&#x27;); if num==x fprintf(&quot;You won!\\n&quot;) break else if x&gt;num fprintf(&quot;High!&quot;) else fprintf(&quot;Low!&quot;) end fprintf(&quot;还剩%d次机会，请再次输入：&quot;,t); endendif t==0 fprintf(&quot;机会为0，游戏结束!\\n&quot;);end Next⬇️Matlab练习1-3 🍺","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"Matlab实验1-1","slug":"Matlab实验1-1","date":"2021-03-03T05:27:52.000Z","updated":"2023-08-25T02:16:39.243Z","comments":true,"path":"2021/03/03/Matlab实验1-1/","link":"","permalink":"http://example.com/2021/03/03/Matlab%E5%AE%9E%E9%AA%8C1-1/","excerpt":"Matlab实验1-1 编写Script命令文件，画出振荡曲线y=e−b3sin3ty =e ^ {- \\frac{b}{3}}sin3ty=e−3b​sin3t及其包络线y0=e−t3y_0=e^{- \\frac{t}{3}} y0​=e−3t​，其中t的取值范围是[0,π][0,\\pi][0,π]. 123456clc;clear;t=0:pi/50:4*pi;y=exp(-t/3).*sin(3*t);y0=exp(-t/3);plot(t,y,&#x27;r&#x27;,t,y0,&#x27;:b&#x27;,t,-y0,&#x27;:b&#x27;);","text":"Matlab实验1-1 编写Script命令文件，画出振荡曲线y=e−b3sin3ty =e ^ {- \\frac{b}{3}}sin3ty=e−3b​sin3t及其包络线y0=e−t3y_0=e^{- \\frac{t}{3}} y0​=e−3t​，其中t的取值范围是[0,π][0,\\pi][0,π]. 123456clc;clear;t=0:pi/50:4*pi;y=exp(-t/3).*sin(3*t);y0=exp(-t/3);plot(t,y,&#x27;r&#x27;,t,y0,&#x27;:b&#x27;,t,-y0,&#x27;:b&#x27;); 编写函数并做调用测试，其中f(x)={lnx+1, x&gt;12x, 0&lt;x⩽1∣x∣, x⩽0f(x)=\\begin{cases} lnx + 1 &amp;\\text{, } x&gt;1 \\\\ \\sqrt {2x} &amp;\\text{, } 0 &lt; x \\leqslant 1 \\\\ |x| &amp;\\text{, } x \\leqslant 0 \\\\ \\end{cases}f(x)=⎩⎪⎪⎨⎪⎪⎧​lnx+12x​∣x∣​, x&gt;1, 0&lt;x⩽1, x⩽0​ 12345678function y = MyFun(x)if x &gt; 1 y = ln(x) + 1;elseif x &gt; 0 &amp;&amp; x &lt;= 1 y = sqrt(2 * x);else y = abs(x);end 计算表达式e10+202log⁡25÷tan20e^{10} + 20^2 \\log_{2} {5} \\div tan20e10+202log2​5÷tan20的值 12format long;exp(10) + (20^2 * log2(5)) / tan(20) 运算结果 12345&gt;&gt; MyCalculate ans = 2.244162199550501e+04 编写函数myf(x)=tan(−x2)arccos(x)myf(x)= tan{(-x^2)}arccos{(x)}myf(x)=tan(−x2)arccos(x)，并测试myf(0.25)myf(0.25)myf(0.25)，myf(0.78)myf(0.78)myf(0.78)的值. 123function y=myf(x) y=tan(-(x^2))*acos(x);end 运算结果 1234567891011&gt;&gt; myf(0.25) ans = -0.082489690911370&gt;&gt; myf(0.78) ans = -0.470951904834096 测试矩阵的一些生成和操作函数，如diag, magic, zeros, ones, eye, tril, triu, rand, 要求把测试的过程和结果放入实验报告. 略 测试数组的生成函数，如from:step:to,linspace，要求把测试的过程和结果放入实验报告. 1234567891011&gt;&gt; A=2:2:100A = Columns 1 through 21 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 Columns 22 through 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 Columns 43 through 50 86 88 90 92 94 96 98 100&gt;&gt; B=linspace(5,100,20)B = 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 测试矩阵或数字的点运算，要求把测试的过程和结果放入实验报告. 123456A = randi(5, 3, 4) %randi(max,row,col)B = magic(4)C = eye(3, 4)D = A * BE = A .* C 运算结果 123456789101112131415161718192021222324252627282930313233343536&gt;&gt; TestCalculateA = 4 2 4 1 4 4 1 1 4 1 2 5B = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1C = 1 0 0 0 0 1 0 0 0 0 1 0D = 114 72 71 117 97 73 73 97 107 103 109 89E = 4 0 0 0 0 4 0 0 0 0 2 0 Next⬇️Matlab练习1-2 🍺","categories":[],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"}]},{"title":"二叉树(Binary Tree)","slug":"二叉树-Binary-Tree","date":"2020-10-23T03:20:10.000Z","updated":"2023-08-25T03:27:46.358Z","comments":true,"path":"2020/10/23/二叉树-Binary-Tree/","link":"","permalink":"http://example.com/2020/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree/","excerpt":"10.23 二叉树BinaryTree上机任务","text":"10.23 二叉树BinaryTree上机任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef struct node&#123; char data; node *parent,*left,*right;&#125;Treenode,*BiTree;typedef struct BinaryTree&#123; Treenode *root; int deepth; int num;&#125;;void CreatTree(BiTree &amp;t)&#123; char c; cin&gt;&gt;c; if (c == &#x27;*&#x27;)&#123; t = NULL; &#125; else&#123; t = new (node); t-&gt;data = c; CreatTree(t-&gt;left); CreatTree(t-&gt;right); &#125; return;&#125;void DFS(node* node)&#123; if (node==NULL)&#123; return;; &#125; cout&lt;&lt;node-&gt;data&lt;&lt;&quot;-&gt;&quot;; if (node-&gt;left!=NULL) DFS(node-&gt;left); if (node-&gt;right!=NULL) DFS(node-&gt;right);&#125;void prettyPrintTree(node* node, string prefix = &quot;&quot;, bool isLeft = true) &#123; if (node == NULL) &#123; cout &lt;&lt; &quot;Empty tree&quot;; return; &#125; if(node-&gt;right) &#123; prettyPrintTree(node-&gt;right, prefix + (isLeft ? &quot;│ &quot; : &quot; &quot;), false); &#125; cout &lt;&lt; prefix + (isLeft ? &quot;└── &quot; : &quot;┌── &quot;) + node-&gt;data + &quot;\\n&quot;; if (node-&gt;left) &#123; prettyPrintTree(node-&gt;left, prefix + (isLeft ? &quot; &quot; : &quot;│ &quot;), true); &#125;&#125;void Mirror(Treenode *node)&#123; if (node == NULL)&#123; return; &#125; swap(node-&gt;left,node-&gt;right); Mirror(node-&gt;left); Mirror(node-&gt;right);&#125;int TreeDepth(Treenode *node)&#123; if(node==NULL) return 0; int left=TreeDepth(node-&gt;left)+1; int right=TreeDepth(node-&gt;right)+1; return left&gt;right?left:right;&#125;int leaf(Treenode *node,int &amp;sum)&#123; if (node==NULL)&#123; return 0; &#125; if (node-&gt;left == NULL&amp;&amp;node-&gt;right == NULL)&#123; sum++; &#125; if (node-&gt;left!=NULL) leaf(node-&gt;left,sum); if (node-&gt;right!=NULL) leaf(node-&gt;right,sum); return sum;&#125;int main() &#123; int sum=0; //叶子数量 BinaryTree t; CreatTree(t.root); DFS(t.root); cout&lt;&lt;endl; prettyPrintTree(t.root); leaf(t.root,sum); cout&lt;&lt;&quot;叶子个数为：&quot;&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;&quot;深度为：&quot;&lt;&lt;TreeDepth(t.root)&lt;&lt;endl; Mirror(t.root); DFS(t.root); cout&lt;&lt;endl; prettyPrintTree(t.root); return 0;&#125;//ABD*F***CE*** | 完成的✅ | 没完成的❌ | | -------------- | ---------------- | | 建立BinaryTree | 中序遍历 | | 前序遍历 | 后序遍历 | | 前序输出 | （逆）波兰表达式 | | 镜像反转 | |","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数组与矩阵","slug":"数组与矩阵","date":"2020-10-13T15:23:11.000Z","updated":"2023-08-25T02:16:39.250Z","comments":true,"path":"2020/10/13/数组与矩阵/","link":"","permalink":"http://example.com/2020/10/13/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/","excerpt":"10.13数组，矩阵（稀疏矩阵，特殊矩阵）稀疏矩阵存储","text":"10.13数组，矩阵（稀疏矩阵，特殊矩阵）稀疏矩阵存储 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667typedef struct &#123; int i , j ; int e;&#125; Triple;typedef struct&#123; Triple data[MAXSIZE+1]; int mu , nu , tu ; //矩阵行数,列数,非零元个数&#125; TSMatrix;void ReserveMatrix1(TSMatrix m,TSMatrix &amp;n)&#123; //一般转置，O(nu*tu) int q; n.tu = m.tu; n.mu = m.nu; n.nu = m.mu; if (m.tu)&#123; q = 1; for (int col = 0; col &lt; m.nu; ++col) &#123; //列遍历 for (int j = 0; j &lt; m.tu; ++j) &#123; if (m.data[j].j == col)&#123; n.data[q].i = m.data[j].j; n.data[q].j = m.data[j].i; n.data[q].e = m.data[j].e; q++; &#125; &#125; &#125; &#125;&#125;void FastTransSMatrix(TSMatrix M , TSMatrix &amp;T) //快速转置，O(nu+tu)&#123; int col,t,p,q,cpot[100],num[100]; T.mu = M.nu; T.nu = M.mu ; T.tu = M.tu; if(T.tu) &#123;//num[col]表示矩阵M中第col列中非0元的个数 for(col=0 ; col&lt;M.nu ; col++) num[col]=0; for(t=0 ; t&lt;M.tu ; t++) ++num[ M.data[t].j ]; cpot[0]=0; for(col=1 ; col&lt;M.nu ; col++) cpot[col] = cpot[col-1] + num[col-1]; for(p=0;p&lt;M.tu;p++) &#123; col= M.data[p].j ; q=cpot[ col ] ; T.data[q].i=M.data[p].j ; T.data[q].j=M.data[p].i ; T.data[q].e=M.data[p].e ; ++cpot[col] ; //cpot[col]表示M中col列下一个非0元在T.data中的位置 &#125;//endfor &#125;//endif&#125;void PrintMatrix(TSMatrix m)&#123; int pp=0; for (int i = 0; i &lt; m.mu; ++i) &#123; for (int j = 0; j &lt; m.nu; ++j) &#123; if ((m.data[pp].i == i)&amp;&amp;(m.data[pp].j == j))&#123; cout&lt;&lt;m.data[pp].e&lt;&lt;&quot; &quot;; pp++; &#125; else&#123; cout&lt;&lt;0&lt;&lt;&quot; &quot;; &#125; &#125; cout&lt;&lt;endl; &#125;&#125; 1稀疏矩阵在转置时不能直接交换i，j的值，因为要考虑转置之后的顺序","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2020-10-06T05:20:33.000Z","updated":"2023-08-25T02:16:39.250Z","comments":true,"path":"2020/10/06/栈与队列/","link":"","permalink":"http://example.com/2020/10/06/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"10.6栈与队列栈 栈不存在的条件：base &#x3D;&#x3D; NULL;栈为空的条件： base &#x3D;&#x3D; top;栈满的条件：top-base &#x3D;&#x3D; stacksize; 初始化栈","text":"10.6栈与队列栈 栈不存在的条件：base &#x3D;&#x3D; NULL;栈为空的条件： base &#x3D;&#x3D; top;栈满的条件：top-base &#x3D;&#x3D; stacksize; 初始化栈 获取栈顶元素 top() 入栈 push() 出栈 pop() 练习一：十进制n转为r进制数123456789101112int n,d,r;std::stack&lt;int&gt;(s);std::cin&gt;&gt;n&gt;&gt;r;while (n!=0)&#123; d = n%r; n = n/r; s.push(d);&#125;while (!s.empty())&#123; std::cout&lt;&lt;s.top(); s.pop();&#125; 练习二：括号匹配1234567891011121314151617char a[20];std::stack&lt;char&gt;(s);cin&gt;&gt;a;for (int i = 0; a[i] != &#x27;\\0&#x27;; ++i) &#123; if (s.empty())&#123; s.push(a[i]); &#125; else if (((s.top() == &#x27;(&#x27;)&amp;&amp;(a[i] == &#x27;)&#x27;))||((s.top() == &#x27;[&#x27;)&amp;&amp;(a[i] == &#x27;]&#x27;))||((s.top() == &#x27;&#123;&#x27;)&amp;&amp;(a[i] == &#x27;&#125;&#x27;)))&#123; s.pop(); &#125; else if (a[i] == &#x27;(&#x27;||a[i] == &#x27;[&#x27;||a[i] == &#x27;&#123;&#x27;)&#123; s.push(a[i]); &#125;&#125;if (s.empty())&#123; cout&lt;&lt;&quot;YES&quot;;&#125; else&#123; cout&lt;&lt;&quot;NO&quot;;&#125; 10.9 队列队列 空队列：front &#x3D;&#x3D; rear满队列：(rear + 1) % max &#x3D;&#x3D; front 循环队列的初始化 入队 出队 10.9 上机栈与队列的基本操作（内含进制转换与括号匹配[STL模版]）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;iostream&gt;#include &lt;stack&gt;//#include &lt;queue&gt;#include &lt;iomanip&gt;#pragma GCC optimize(2)using namespace std;typedef struct node &#123; int data; node *next;&#125;Qnode,Snode;typedef struct&#123; Qnode *rear,*front;&#125;Qlink;typedef struct&#123; Snode *base,*top;&#125;Slink;void InitStack(Slink &amp;s)&#123; s.top = s.base = NULL;&#125;void push(Slink &amp;s,int n)&#123; Snode *p; p = new (Snode); p-&gt;data = n; p-&gt;next = NULL; if (s.base == NULL)&#123; s.top = s.base = p; &#125; else&#123; s.top-&gt;next = p; s.top = p; &#125;&#125;void pop(Slink &amp;s)&#123; Snode *p; p = s.base; if ((s.base == s.top)&amp;&amp;(s.base != NULL))&#123; free(s.base); s.base = s.top = NULL; return; &#125; while (p-&gt;next != s.top) p = p-&gt;next; s.top = p; free(p-&gt;next); p-&gt;next =NULL;&#125;int top(Slink s)&#123; return s.top-&gt;data;&#125;int empty(Slink s)&#123; if (s.base == NULL) return 1; else return 0;&#125;void InitQue(Qlink &amp;q)&#123; Qnode *p = new (node); p-&gt;next = NULL; q.rear = q.front = p;&#125;void InsertQue(Qlink &amp;q,int n)&#123; Qnode *p = new (node); p-&gt;data = n; p-&gt;next = NULL; q.rear-&gt;next = p; q.rear = p;&#125;void DelQue(Qlink &amp;q,int &amp;e)&#123; if (q.front == q.rear)&#123; return; &#125; Qnode *p; p = q.front; e = q.front-&gt;next-&gt;data; q.front = q.front-&gt;next; free(p);&#125;void PrintQue(Qlink q)&#123; Qnode *p; p = q.front-&gt;next; while (p != NULL)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125;&#125;int main() &#123; int temp; Qlink q; InitQue(q); cin&gt;&gt;temp; for (int i = 0; i &lt; temp; ++i) &#123; InsertQue(q,rand()%100); &#125; cout&lt;&lt;&quot;输出队列：&quot;&lt;&lt;endl; PrintQue(q); DelQue(q,temp); cout&lt;&lt;endl; cout&lt;&lt;&quot;出队元素：&quot;; cout&lt;&lt;temp&lt;&lt;endl; cout&lt;&lt;&quot;出队后队列：&quot;&lt;&lt;endl; PrintQue(q); cout&lt;&lt;endl; //TODO: Slink s; InitStack(s); cin&gt;&gt;temp; for (int i = 0; i &lt; temp; ++i) &#123; push(s,rand()%100); &#125; cout&lt;&lt;&quot;压栈完成：&quot;&lt;&lt;endl; for (int i = 0; i &lt; temp; ++i) &#123; int t = top(s); cout&lt;&lt;t&lt;&lt;&quot; &quot;; pop(s); &#125; cout&lt;&lt;endl; int n,r,d; cout&lt;&lt;&quot;进制转换,输入十进制数n与目标进制r:&quot;&lt;&lt;endl; InitStack(s); cin&gt;&gt;n&gt;&gt;r; while (n!=0)&#123; d = n%r; n = n/r; push(s,d); &#125; cout&lt;&lt;&quot;转换完成：&quot;; while (!empty(s))&#123; std::cout&lt;&lt;top(s); pop(s); &#125; cout&lt;&lt;&quot;(&quot;&lt;&lt;r&lt;&lt;&quot;)&quot;&lt;&lt;endl; cout&lt;&lt;&quot;括号匹配，输入一行括号：&quot;&lt;&lt;endl; char a[100]; stack&lt;char&gt;(S); cin&gt;&gt;a; for (int i = 0; a[i] != &#x27;\\0&#x27;; ++i) &#123; if (S.empty())&#123; S.push(a[i]); &#125; else if (((S.top() == &#x27;(&#x27;)&amp;&amp;(a[i] == &#x27;)&#x27;))||((S.top() == &#x27;[&#x27;)&amp;&amp;(a[i] == &#x27;]&#x27;))||((S.top() == &#x27;&#123;&#x27;)&amp;&amp;(a[i] == &#x27;&#125;&#x27;)))&#123; S.pop(); &#125; else if (a[i] == &#x27;(&#x27;||a[i] == &#x27;[&#x27;||a[i] == &#x27;&#123;&#x27;)&#123; S.push(a[i]); &#125; &#125; if (S.empty())&#123; cout&lt;&lt;&quot;YES&quot;; &#125; else&#123; cout&lt;&lt;&quot;NO&quot;; &#125;&#125;/* * //TODO:进制转换 * int n,d,r; stack&lt;int&gt;(s); cin&gt;&gt;n&gt;&gt;r; while (n!=0)&#123; d = n%r; n = n/r; s.push(d); &#125; while (!s.empty())&#123; std::cout&lt;&lt;s.top(); s.pop(); &#125;*//* * //TODO:括号匹配 * char a[20]; stack&lt;char&gt;(s); cin&gt;&gt;a; for (int i = 0; a[i] != &#x27;\\0&#x27;; ++i) &#123; if (s.empty())&#123; s.push(a[i]); &#125; else if (((s.top() == &#x27;(&#x27;)&amp;&amp;(a[i] == &#x27;)&#x27;))||((s.top() == &#x27;[&#x27;)&amp;&amp;(a[i] == &#x27;]&#x27;))||((s.top() == &#x27;&#123;&#x27;)&amp;&amp;(a[i] == &#x27;&#125;&#x27;)))&#123; s.pop(); &#125; else if (a[i] == &#x27;(&#x27;||a[i] == &#x27;[&#x27;||a[i] == &#x27;&#123;&#x27;)&#123; s.push(a[i]); &#125; &#125; if (s.empty())&#123; cout&lt;&lt;&quot;YES&quot;; &#125; else&#123; cout&lt;&lt;&quot;NO&quot;; &#125;*/ 栈实现计算表达式的值&#96;&#96;使用STL模版&#96;&#96;&#96; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;stack&gt;#pragma GCC optimize(2)using namespace std;//stack&lt;char&gt; OPTR;//stack&lt;double&gt; OPND;typedef struct node &#123; char data; node *next;&#125;Qnode,Snode;typedef struct Cnode &#123; int data; Cnode *next;&#125;SnodeC;typedef struct&#123; Qnode *rear,*front;&#125;Qlink;typedef struct&#123; SnodeC *base,*top;&#125;SlinkC;typedef struct &#123; Snode *base, *top;&#125;Slink;template&lt;class T&gt;void InitStack(T &amp;s)&#123; s.top = s.base = NULL;&#125;//void InitStack(Slink &amp;s)&#123;// s.top = s.base = NULL;//&#125;////void InitStack(SlinkC &amp;s)&#123;// s.top = s.base = NULL;//&#125;void push(Slink &amp;s,int n)&#123; Snode *p; p = new (Snode); p-&gt;data = n; p-&gt;next = NULL; if (s.base == NULL)&#123; s.top = s.base = p; &#125; else&#123; s.top-&gt;next = p; s.top = p; &#125;&#125;void push(SlinkC &amp;s,char n)&#123; SnodeC *p; p = new (SnodeC); p-&gt;data = n; p-&gt;next = NULL; if (s.base == NULL)&#123; s.top = s.base = p; &#125; else&#123; s.top-&gt;next = p; s.top = p; &#125;&#125;void pop(Slink &amp;s)&#123; Snode *p; p = s.base; if ((s.base == s.top)&amp;&amp;(s.base != NULL))&#123; free(s.base); s.base = s.top = NULL; return; &#125; while (p-&gt;next != s.top) p = p-&gt;next; s.top = p; free(p-&gt;next); p-&gt;next =NULL;&#125;void pop(SlinkC &amp;s)&#123; SnodeC *p; p = s.base; if ((s.base == s.top)&amp;&amp;(s.base != NULL))&#123; free(s.base); s.base = s.top = NULL; return; &#125; while (p-&gt;next != s.top) p = p-&gt;next; s.top = p; free(p-&gt;next); p-&gt;next =NULL;&#125;int top(Slink s)&#123; return s.top-&gt;data;&#125;char top(SlinkC s)&#123; return s.top-&gt;data;&#125;template&lt;class T&gt;int empty(T s)&#123; if (s.base == NULL) return 1; else return 0;&#125;int getIndex(char theta) //中文&quot;（&quot;与&quot;）&quot;不可用&#123; int index = 0; switch (theta) &#123; case &#x27;+&#x27;: index = 0; break; case &#x27;-&#x27;: index = 1; break; case &#x27;*&#x27;: index = 2; break; case &#x27;/&#x27;: index = 3; break; case &#x27;(&#x27;: index = 4; break; case &#x27;)&#x27;: index = 5; break; case &#x27;#&#x27;: index = 6; default:break; &#125; return index;&#125;char Precede(char theta1, char theta2)&#123; const char priority[][7] = //优先度 &#123; &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;0&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;0&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;0&#x27;,&#x27;=&#x27; &#125;, &#125;; int index1 = getIndex(theta1); int index2 = getIndex(theta2); return priority[index1][index2];&#125;double calculate(double b, char theta, double a)&#123; switch (theta) &#123; case &#x27;+&#x27;: return b + a; case &#x27;-&#x27;: return b - a; case &#x27;*&#x27;: return b * a; case &#x27;/&#x27;: return b / a; default: break; &#125;&#125;double getAnswer(SlinkC &amp;OPTR,Slink &amp;OPND)&#123; push(OPTR,&#x27;#&#x27;); int counter = 0; //用来记录数字的位数 char c = getchar(); while (c != &#x27;#&#x27; || top(OPTR) != &#x27;#&#x27;) &#123; if (isdigit(c)) //判断是否是数字 &#123; if (counter == 1) &#123; double t = top(OPND); //保留栈顶 pop(OPND); push(OPND,t * 10 + (c - &#x27;0&#x27;)); counter = 1; &#125; else &#123; push(OPND,c - &#x27;0&#x27;); counter++; //第二位也是数字，则counter变为1，弹出原有数字并压入新的数字 &#125; c = getchar(); &#125; else &#123; counter = 0; //数字结束 switch (Precede(top(OPTR), c)) &#123; case &#x27;&lt;&#x27;: push(OPTR,c); c = getchar(); break; case &#x27;=&#x27;: pop(OPTR); c = getchar(); break; case &#x27;&gt;&#x27;: char theta = top(OPTR); pop(OPTR); double a = top(OPND); pop(OPND); double b = top(OPND); pop(OPND); push(OPND,calculate(b, theta, a)); &#125; &#125; &#125; return top(OPND);&#125;template&lt;class T&gt;void clearstack(T s) //清空栈&#123; while (!empty(s)) pop(s);&#125;int main()&#123; Slink OPND; SlinkC OPTR; InitStack(OPND); InitStack(OPTR); int t; cin &gt;&gt; t; getchar(); while (t--) &#123; clearstack(OPND); clearstack(OPTR); double ans = getAnswer(OPTR,OPND); cout &lt;&lt; ans &lt;&lt; endl&lt;&lt; endl; getchar(); &#125; return 0;&#125; 未使用STL，正常做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;stack&gt;#pragma GCC optimize(2)using namespace std;stack&lt;char&gt; OPTR;stack&lt;double&gt; OPND;int getIndex(char theta) //将运算符转为下标&#123; int index = 0; switch (theta) &#123; case &#x27;+&#x27;: index = 0; break; case &#x27;-&#x27;: index = 1; break; case &#x27;*&#x27;: index = 2; break; case &#x27;/&#x27;: index = 3; break; case &#x27;(&#x27;: index = 4; break; case &#x27;)&#x27;: index = 5; break; case &#x27;#&#x27;: index = 6; default:break; &#125; return index;&#125;char Precede(char theta1, char theta2) //计算优先度&#123; const char priority[][7] = &#123; &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;0&#x27; &#125;, &#123; &#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;0&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27; &#125;, &#123; &#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;0&#x27;,&#x27;=&#x27; &#125;, &#125;; int index1 = getIndex(theta1); int index2 = getIndex(theta2); return priority[index1][index2];&#125;double calculate(double b, char theta, double a) //根据theta计算结果&#123; switch (theta) &#123; case &#x27;+&#x27;: return b + a; case &#x27;-&#x27;: return b - a; case &#x27;*&#x27;: return b * a; case &#x27;/&#x27;: return b / a; default: break; &#125;&#125;double getAnswer()&#123; OPTR.push(&#x27;#&#x27;); int counter = 0; char c = getchar(); while (c != &#x27;#&#x27; || OPTR.top() != &#x27;#&#x27;) &#123; if (isdigit(c)) //如果是数字则进入OPND栈中 &#123; if (counter == 1) //可能为两位数或者是更多位数，所以要先判断前一个数是否为数字 &#123; double t = OPND.top(); OPND.pop(); OPND.push(t * 10 + (c - &#x27;0&#x27;)); counter = 1; &#125; else &#123; OPND.push(c - &#x27;0&#x27;); counter++; &#125; c = getchar(); &#125; else //如果是运算符，则判断 &#123; counter = 0; switch (Precede(OPTR.top(), c)) &#123; case &#x27;&lt;&#x27;: OPTR.push(c); c = getchar(); break; case &#x27;=&#x27;: OPTR.pop(); c = getchar(); break; case &#x27;&gt;&#x27;: char theta = OPTR.top(); OPTR.pop(); double a = OPND.top(); //计算a与b运算的值，并将运算得到的结果压入栈中 OPND.pop(); double b = OPND.top(); OPND.pop(); //弹出a，b，并将运算结果存入 OPND.push(calculate(b,theta,a)); &#125; &#125; &#125; return OPND.top();&#125;void clearstack() //清空栈&#123; while (!OPTR.empty()) OPTR.pop(); while (!OPND.empty()) OPND.pop();&#125;int main()&#123; int t; cin &gt;&gt; t; getchar(); while (t--) &#123; clearstack(); double ans = getAnswer(); cout &lt;&lt; ans &lt;&lt; endl&lt;&lt; endl; getchar(); &#125; return 0;&#125; 逆波兰表达式、波兰表达式","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"顺序表与链表","slug":"顺序表与链表","date":"2020-10-02T07:20:22.000Z","updated":"2023-08-25T02:16:39.252Z","comments":true,"path":"2020/10/02/顺序表与链表/","link":"","permalink":"http://example.com/2020/10/02/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8/","excerpt":"顺序表与链表 Before-1 顺序表的创立 顺序表的随机初始化（头插法以及尾插法） 顺序表的定位 顺序表插入删除以及定位元素 求顺序表的交集与并集","text":"顺序表与链表 Before-1 顺序表的创立 顺序表的随机初始化（头插法以及尾插法） 顺序表的定位 顺序表插入删除以及定位元素 求顺序表的交集与并集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#include &lt;iostream&gt;#define List_Size 100using namespace std;struct SqList&#123; int *elem; int len; int size;&#125;;//TODO Listbool InitList(SqList &amp;L);bool RandInitList(SqList &amp;L,int n);bool ListInsert(SqList &amp;L,int i,int e);bool PrintList(SqList L);bool DeletList(SqList &amp;L,int n);int LocateElem(SqList L,int elem);int comp(const void*a,const void*b);bool IntersectionElem(SqList La,SqList Lb);SqList *MergeList(SqList La,SqList Lb);//TODO functionbool InitList(SqList &amp;L)&#123; L.elem=(int *)malloc(List_Size*sizeof(int)); if (!L.elem)&#123; exit(-2); &#125; L.len = 0; L.size = List_Size; return 1;&#125;bool RandInitList(SqList &amp;L,int n)&#123; if (n&gt;=0&amp;&amp;n&lt;List_Size&amp;&amp;InitList(L)==1)&#123; for (int i = 0; i &lt; n; ++i) &#123; L.elem[i] = rand()%100; &#125; L.len = n; return 1; &#125; return 0;&#125;bool ListInsert(SqList &amp;L,int i,int e)&#123; if (i&lt;1||i&gt;L.len + 1)&#123; return 0; &#125; if (L.len &gt; L.size)&#123; int *newbase = (int *)realloc(L.elem,(L.size+1)*sizeof(int)); if (!newbase) exit(-2); L.elem = newbase; L.size += 1; &#125; int *q=&amp;(L.elem[i-1]); for (int *p = &amp;(L.elem[L.len - 1]); p&gt;=q; --p) &#123; *(p+1) = *p; &#125; *q = e; ++L.len; return 1;&#125;bool PrintList(SqList L)&#123; for (int i = 0; i &lt; L.len; ++i) &#123; cout&lt;&lt;L.elem[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;bool DeletList(SqList &amp;L,int n)&#123; if (n &lt; 1||n&gt;L.len)&#123; return 0; &#125; else&#123; for (int i = n; i &lt; L.len; ++i) &#123; L.elem[i-1] = L.elem[i]; &#125; L.len--; return 1; &#125;&#125;int LocateElem(SqList L,int elem)&#123; for (int i = 0; i &lt; L.len; ++i) &#123; if (L.elem[i] == elem)&#123; return i+1; &#125; &#125; return 0;&#125;int comp(const void*a,const void*b)&#123; return *(int*)a-*(int*)b;&#125;SqList *MergeList(SqList La,SqList Lb)&#123; SqList L; InitList(L); int i=0,j=0,k=0; while ((i &lt; La.len)&amp;&amp;(j &lt; Lb.len))&#123; if (La.elem[i]&lt;Lb.elem[j])&#123; L.elem[k] = La.elem[i]; i++; k++; &#125; else&#123; L.elem[k] = Lb.elem[j]; j++; k++; &#125; &#125; if (i == La.len)&#123; for (int l = j; l &lt; Lb.len; ++l) &#123; L.elem[k++] = Lb.elem[l]; &#125; &#125; else&#123; for (int l = i; l &lt; La.len; ++l) &#123; L.elem[k++] = La.elem[l]; &#125; &#125; L.len = La.len + Lb.len; return &amp;L;&#125;bool IntersectionElem(SqList La,SqList Lb)&#123; int Min = min(La.len,Lb.len),flag= false; if (Min == La.len)&#123; for (int i = 0; i &lt; La.len; ++i) &#123; for (int j = 0; j &lt; Lb.len; ++j) &#123; if (La.elem[i] == Lb.elem[j])&#123; if (flag)&#123; printf(&quot;%d &quot;,La.elem[i]); break; &#125; else&#123; flag = true; printf(&quot;交集元素为：\\n&quot;); printf(&quot;%d &quot;,La.elem[i]); break; &#125; &#125; &#125; &#125; &#125; else&#123; for (int i = 0; i &lt; Lb.len; ++i) &#123; for (int j = 0; j &lt; La.len; ++j) &#123; if (Lb.elem[i] == La.elem[j])&#123; if (flag)&#123; printf(&quot;%d &quot;,Lb.elem[i]); break; &#125; else&#123; flag = true; printf(&quot;交集元素为：\\n&quot;); printf(&quot;%d &quot;,Lb.elem[i]); break; &#125; &#125; &#125; &#125; &#125; return flag;&#125;//TODO Main Functionint main() &#123; int n,oper,insert_loc,insert_elem,delet_loc,find_elem; SqList La,Lb; printf(&quot;开始初始化，输入元素个数：\\n&quot;); cin&gt;&gt;n; if (RandInitList(La,n)&amp;&amp;(RandInitList(Lb,n)))&#123; printf(&quot;随机初始化成功,list为：\\n&quot;); PrintList(La); PrintList(Lb); &#125; else&#123; printf(&quot;初始化失败\\n&quot;); &#125; do &#123; printf(&quot;__________________\\n&quot; &quot;输入操作：\\n&quot; &quot;1:插入\\n&quot; &quot;2:删除\\n&quot; &quot;3:查找\\n&quot; &quot;4:排序\\n&quot; &quot;5:合并\\n&quot; &quot;6:交集\\n&quot; &quot;0:退出\\n&quot; &quot;___________________\\n&quot;); scanf(&quot;%d&quot;,&amp;oper); switch (oper) &#123; case 1:&#123; printf(&quot;输入插入的位置以及插入的元素：&quot;); scanf(&quot;%d %d&quot;,&amp;insert_loc,&amp;insert_elem); if (ListInsert(La,insert_loc,insert_elem))&#123; printf(&quot;插入成功，list为：\\n&quot;); PrintList(La); &#125; else&#123; printf(&quot;插入失败\\n&quot;); &#125; break; &#125; case 2:&#123; printf(&quot;请输入删除的位置：\\n&quot;); scanf(&quot;%d&quot;,&amp;delet_loc); if (DeletList(La,delet_loc))&#123; printf(&quot;删除成功，删除后的list为：\\n&quot;); PrintList(La); &#125; else&#123; printf(&quot;删除失败\\n&quot;); &#125; break; &#125; case 3:&#123; printf(&quot;请输入要查找的元素：\\n&quot;); scanf(&quot;%d&quot;,&amp;find_elem); if (int i=LocateElem(La,find_elem))&#123; printf(&quot;查找成功，位置为：%d\\n&quot;,i); &#125; else&#123; printf(&quot;查找失败\\n&quot;); &#125; break; &#125; case 4:&#123; qsort(La.elem,La.len,sizeof(int),comp); qsort(Lb.elem,Lb.len,sizeof(int),comp); printf(&quot;排序完成\\n&quot;); PrintList(La); PrintList(Lb); break; &#125; case 5:&#123; qsort(La.elem,La.len,sizeof(int),comp); qsort(Lb.elem,Lb.len,sizeof(int),comp); printf(&quot;排序完成\\n&quot;); SqList *pL=MergeList(La,Lb); printf(&quot;合并完成，list为：\\n&quot;); PrintList(*pL); break; &#125; case 6:&#123; if (IntersectionElem(La,Lb))&#123; printf(&quot;\\n&quot;); &#125; else&#123; printf(&quot;无交集元素\\n&quot;); &#125; break; &#125; case 0:&#123; exit(0); &#125; default:&#123; printf(&quot;无此操作\\n&quot;); break; &#125; &#125; &#125;while (oper != 0); return 0;&#125; Before-2 头插法创建链表 尾插法创建链表 链表合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;using namespace std;typedef struct node&#123; int data; node *next;&#125;*LinkList;typedef struct DuList&#123; int data; DuList *prior; DuList *next;&#125;*DLinkList;void CreatDuList(DLinkList &amp;L,int n)&#123; DLinkList p,q; L = new (DuList); L-&gt;next = NULL; L-&gt;prior = NULL; q = L; for (int i = 0; i &lt; n; ++i) &#123; p = *new (DLinkList); p-&gt;data = rand()%100; p-&gt;prior = q; q-&gt;next = p; q = p; &#125;&#125;void PrintDuList1(DLinkList L)&#123; DLinkList p = L; while (p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;endl;&#125;void PrintDuList2(DLinkList L)&#123; DLinkList p = L; while (p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;prior; &#125; cout&lt;&lt;endl;&#125;void DuInsert(DLinkList &amp;L,int i)&#123; int cnt = 0; DLinkList p,q; q = L; p = (DLinkList) malloc(sizeof(DLinkList)); while (q&amp;&amp;(cnt&lt;i))&#123; q = q-&gt;next; cnt++; &#125; p-&gt;prior = q-&gt;prior; q-&gt;prior-&gt;next = p; q-&gt;prior = p; p-&gt;next = q;&#125;void CreatListHead(LinkList &amp;L,int n)&#123; LinkList p; L = new (node); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i) &#123; p = (LinkList) malloc(sizeof(node)); p-&gt;data = rand()%100; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;void CreatListTail(LinkList &amp;L,int n)&#123; LinkList p,q; L = new (node); q =L; for (int i = 0; i &lt; n; ++i) &#123; p = new (node); p-&gt;data = rand()%100; q-&gt;next = p; q = p; &#125; q-&gt;next =NULL;&#125;void Insert(LinkList &amp;L,int i,int e)&#123; int cnt=0; LinkList p,q; p = L; q = new (node); while (p&amp;&amp;(cnt &lt; i-1))&#123; cnt++; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; q-&gt;data = e; p-&gt;next = q;&#125;void Delet(LinkList &amp;L,int i)&#123; int cnt=0; LinkList p; p = L; while (p&amp;&amp;(cnt &lt; i-1))&#123; cnt++; p = p-&gt;next; &#125; p-&gt;next = (*(p-&gt;next)).next;&#125;void PrintList(LinkList L)&#123; int sum=0; for (LinkList p=L-&gt;next;p != NULL;p = p-&gt;next)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; sum++; &#125; cout&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;&#125;void MergeList(LinkList &amp;L1,LinkList &amp;L2,LinkList &amp;L3)&#123; int i=0; LinkList p1,p2; L3 = new (node); p1 = L1;p2 = L2; while (p1&amp;&amp;p2)&#123; if (p1-&gt;data &lt; p2-&gt;data) &#123; Insert(L3, i, p1-&gt;data); p1 = p1-&gt;next; &#125; else &#123; Insert(L3, i, p2-&gt;data); p2 = p2-&gt;next; &#125; i++; &#125;&#125;int main()&#123; int n; LinkList L1,L2,L3; L3 = new (node); cin&gt;&gt;n; CreatListHead(L1,n);// CreatListTail(L2,n); PrintList(L1); CreatListTail(L2,n); PrintList(L2); Insert(L1,2,3); PrintList(L1); Delet(L1,2); PrintList(L1); PrintList(L3); MergeList(L1,L2,L3); PrintList(L3);// int n;// cin&gt;&gt;n;// DLinkList L1,L2;// CreatDuList(L1,n);// PrintDuList1(L1);// PrintDuList2(L1);&#125; 10.2上机作业：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;using namespace std;typedef struct node //单链表&#123; int data; struct node *next;&#125; *NodeList;typedef struct SqList &#123; //顺序表 int *elem; int len; int size;&#125;;NodeList *createEnd(NodeList &amp;head,int len) //单链表创立尾插法&#123; head = (node *)malloc(sizeof(NodeList)); head-&gt;next = NULL; NodeList end = head; for (int i = 0; i &lt; len; i++) &#123; NodeList p = (NodeList)malloc(sizeof(node)); p-&gt;data= rand()%100; end-&gt;next = p; end = p; &#125; end-&gt;next = NULL;&#125;void Print(NodeList head) //单链表输出&#123; int i = 0; if (head == NULL) return; NodeList p = head-&gt;next; while (p != NULL) &#123; printf(&quot;%4d&quot;,p-&gt;data); p = p-&gt;next; if ((i+1)%5 == 0)&#123; cout&lt;&lt;endl; &#125; i++; &#125; cout&lt;&lt;endl;&#125;void DeletElem(NodeList &amp;head,SqList &amp;T) //单链表删除&#123; int i = 0,j = 0; NodeList p,q,temp; NodeList s = head; T.size = 1000; T.elem = (int*)malloc(T.size * sizeof(int)); T.len = 0; p = s-&gt;next; while(p != NULL) &#123; q = p; while(q-&gt;next != NULL) &#123; if(q-&gt;next-&gt;data == p-&gt;data) &#123; temp = q-&gt;next; q-&gt;next = q-&gt;next-&gt;next; T.elem[T.len++] = p-&gt;data+(i+j+1)*100; free(temp); &#125; q = q-&gt;next; j++; &#125; j = 0; i++; p = p-&gt;next; &#125;&#125;void CreatList(SqList &amp;L,int n)&#123; //顺序表创建 L.elem = (int*)malloc(n*sizeof(int)); for (int i = 0; i &lt; n; ++i) &#123; L.elem[i] = rand()%100; &#125; L.len = n;&#125;void PrintList(SqList L)&#123; //顺序表输出 for (int i = 0; i &lt; L.len; ++i) &#123; printf(&quot;%4d&quot;,L.elem[i]); if ((i+1)%5 == 0)&#123; cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;endl;&#125;void DeletElem(SqList &amp;L,SqList &amp;T)&#123; //顺序表删除 T.len = 0; T.elem = (int *)malloc(L.len * sizeof(int )); for (int i = 0; i &lt;L.len; ++i) &#123; for (int j = i+1; j &lt; L.len; ++j) &#123; if (L.elem[j] == L.elem[i])&#123; for (int k = j; k &lt; L.len - 1; ++k) &#123; L.elem[k] = L.elem[k+1]; &#125; T.elem[T.len++] = L.elem[i]+j*100; L.len--; &#125; &#125; &#125;&#125;void ReverseLink(NodeList &amp;Head) //单链表倒置&#123; int flag=0; if (Head == NULL) &#123; return; &#125; NodeList pNode = Head-&gt;next; NodeList Prev = NULL; NodeList pNext = NULL; while (pNode != NULL)&#123; pNext = pNode-&gt;next; if (pNext == NULL)&#123; Head = pNode; &#125; pNode-&gt;next = Prev; Prev = pNode; pNode = pNext; &#125; NodeList p = (NodeList)malloc(sizeof(int)); p-&gt;next = Head; Head = p;&#125;int main()&#123; int n,*a; SqList T; cin&gt;&gt;n; //TODO:删除顺序表中的重复元素 SqList L; CreatList(L,n); cout&lt;&lt;&quot;顺序表创建完成:&quot;&lt;&lt;endl; PrintList(L); DeletElem(L,T); cout&lt;&lt;&quot;顺序表删除完成:&quot;&lt;&lt;endl; PrintList(L); if (T.len != 0)&#123; cout&lt;&lt;&quot;删除的元素为:&quot;&lt;&lt;endl; for (int i = 0; i &lt; T.len; ++i) &#123; cout&lt;&lt;&quot;原位置为:&quot;&lt;&lt;T.elem[i]/100+1&lt;&lt;&quot;-&gt;&quot;&lt;&lt;T.elem[i]%100&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; else&#123; cout&lt;&lt;&quot;无重复元素&quot;&lt;&lt;endl; &#125; //TODO:删除链表中的重复元素 NodeList head; createEnd(head,n); cout&lt;&lt;&quot;单链表创建完成:&quot;&lt;&lt;endl; Print(head); DeletElem(head,T); cout&lt;&lt;&quot;单链表删除完成:&quot;&lt;&lt;endl; Print(head); if (T.len != 0)&#123; cout&lt;&lt;&quot;删除的元素为:&quot;&lt;&lt;endl; for (int i = 0; i &lt; T.len; ++i) &#123; cout&lt;&lt;&quot;原位置为:&quot;&lt;&lt;T.elem[i]/100+1&lt;&lt;&quot;-&gt;&quot;&lt;&lt;T.elem[i]%100&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; else&#123; cout&lt;&lt;&quot;无重复元素&quot;&lt;&lt;endl; &#125; //TODO:单链表的逆置 ReverseLink(head); cout&lt;&lt;&quot;单链表逆置完成:&quot;&lt;&lt;endl; Print(head);&#125; 顺序表中删除重复元素 单链表中删除重复元素 单链表的逆置","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"实习日记","slug":"实习日记","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"CaNS","slug":"CaNS","permalink":"http://example.com/tags/CaNS/"},{"name":"流体力学","slug":"流体力学","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6/"},{"name":"工业仿真","slug":"工业仿真","permalink":"http://example.com/tags/%E5%B7%A5%E4%B8%9A%E4%BB%BF%E7%9C%9F/"},{"name":"海洋科学","slug":"海洋科学","permalink":"http://example.com/tags/%E6%B5%B7%E6%B4%8B%E7%A7%91%E5%AD%A6/"},{"name":"suntans","slug":"suntans","permalink":"http://example.com/tags/suntans/"},{"name":"sunplot","slug":"sunplot","permalink":"http://example.com/tags/sunplot/"},{"name":"安装指北","slug":"安装指北","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/"},{"name":"MITgcm","slug":"MITgcm","permalink":"http://example.com/tags/MITgcm/"},{"name":"气候气象","slug":"气候气象","permalink":"http://example.com/tags/%E6%B0%94%E5%80%99%E6%B0%94%E8%B1%A1/"},{"name":"CMAQ","slug":"CMAQ","permalink":"http://example.com/tags/CMAQ/"},{"name":"ioapi","slug":"ioapi","permalink":"http://example.com/tags/ioapi/"},{"name":"环境科学","slug":"环境科学","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E7%A7%91%E5%AD%A6/"},{"name":"parmetis","slug":"parmetis","permalink":"http://example.com/tags/parmetis/"},{"name":"swan","slug":"swan","permalink":"http://example.com/tags/swan/"},{"name":"presto-c","slug":"presto-c","permalink":"http://example.com/tags/presto-c/"},{"name":"FVCOM","slug":"FVCOM","permalink":"http://example.com/tags/FVCOM/"},{"name":"vasp","slug":"vasp","permalink":"http://example.com/tags/vasp/"},{"name":"分子动力学","slug":"分子动力学","permalink":"http://example.com/tags/%E5%88%86%E5%AD%90%E5%8A%A8%E5%8A%9B%E5%AD%A6/"},{"name":"ABACUS","slug":"ABACUS","permalink":"http://example.com/tags/ABACUS/"},{"name":"gromacs","slug":"gromacs","permalink":"http://example.com/tags/gromacs/"},{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/tags/Matlab/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"demo","slug":"demo","permalink":"http://example.com/tags/demo/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}